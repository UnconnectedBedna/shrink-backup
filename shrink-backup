#!/usr/bin/env bash
#
# shrink-backup
# Version 1.4-beta
# Backup tool for creating and updating .img files (with autoexpansion function) on various linux operating systems
#
#    Copyright (c) 2024-present, Marcus Johansson
#    https://github.com/UnconnectedBedna/shrink-backup
#    All rights reserved.
#
#    This source code is licensed under the BSD-style license found in the
#    LICENSE file in the root directory of this source tree.
##############################################################################



function debug() {
  local log_level="$1"
  local log_message="$2"
  if [ "$DEBUG" = true ]; then
    if [ "$log_level" = 'BREAK' ]; then
      echo '-------------------------------------------------------------------------------------' >> "$LOG_FILE"
    else
      if [ $log_level = 'INFO' ]; then
        echo -e "$(date +"%Y-%m-%d %H:%M:%S") [$log_level]    - $log_message" >> "$LOG_FILE"
      elif [ $log_level = 'ERROR' ]; then
        echo -e "$(date +"%Y-%m-%d %H:%M:%S") [$log_level]   - $log_message" >> "$LOG_FILE"
      elif [ $log_level = 'WARNING' ]; then
        echo -e "$(date +"%Y-%m-%d %H:%M:%S") [$log_level] - $log_message" >> "$LOG_FILE"
      else
        echo -e "$(date +"%Y-%m-%d %H:%M:%S") [$log_level]   - $log_message" >> "$LOG_FILE"
      fi
    fi
  fi
return 0
}



# Function to clean up resources on script exit or termination
function cleanup() {
  # exit 0 = cleanup after script
  # exit 1 = early/clean error
  # exit 2 = help, version & looprun
  # exit 3 = later/normal error
  # exit 4 = aborted by user
  # exit 5 = rsync error
  # exit 10 = stopped by user (ctrl+c)
  local exit_code="$?"

  # Kill tail operation hindering unmounting of boot partition & delete lock file
  debug 'DEBUG' "Killing tail operation and removing ${BOOT_PATH}/shrink-backup.lock"
  pkill tail
  rm "$BOOT_PATH"/shrink-backup.lock 2>/dev/null

  if [ "$exit_code" -ne 1 ] && [ "$exit_code" -ne 2 ]; then
    case $exit_code in
      0) debug 'DEBUG' 'Cleanup function called with exit 0';;
      4) debug 'WARNING' 'Script aborted by user, cleanup exit 4';;
      5) debug 'ERROR' 'Script failed during rsync, cleanup exit 5';;
      10) echo -e "\n${Yellow}!! Script aborted by user with ctrl+c..."; debug 'WARNING' 'Script stopped by user with ctrl+c, cleanup exit 10';;
      *) echo -e "${Yellow}!! Cleanup function called with non-zero exit code, something went wrong!!!"; debug 'ERROR' "Cleanup function called with non zero exit code: exit $exit_code";;
    esac

    echo -e "${White}## ${IWhite}Exiting and cleaning up..."
    echo -e "${White}## ${IWhite}Please stand by..."

    # Unmount img boot
    if [ -n "$BOOT_PATH" ] && [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}${BOOT_PATH} " /proc/mounts; then
      # Loop until the mount point is not busy
      while true; do
        # Check if the mount point is busy
        if ! umount "${TMP_DIR}${BOOT_PATH}" && grep -qs "${TMP_DIR}${BOOT_PATH} " /proc/mounts; then
          # If it is, sleep for 5 seconds and try again
          echo -e "${Yellow}!! ${Green}${TMP_DIR}${BOOT_PATH} ${Yellow}is busy, retrying in 5 seconds..."
          debug 'DEBUG' "${TMP_DIR}${BOOT_PATH} is busy, retrying in 5 seconds"
          sleep 5
        else
          debug 'DEBUG' "Unmounting boot partition in cleanup function: umount ${TMP_DIR}${BOOT_PATH}"
          break
        fi
      done
    fi

    # btrfs
    if [ "$FSTYPE" == 'btrfs' ]; then
      # Non-root subvolumes
      for subvol in "${LOCAL_TOP_SUBVOLUMES[@]}"; do
        if grep -q "$subvol" /etc/fstab && [[ "$subvol" != '@' ]]; then
          path=$(cat /etc/fstab | grep "$subvol" | awk '{print $2}')
          if [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}${path} " /proc/mounts; then
            while true; do
              if ! umount "${TMP_DIR}${path}" && grep -qs "${TMP_DIR}${path} " /proc/mounts; then
                echo -e "${Yellow}!! ${Green}${TMP_DIR}${path} ${Yellow}is busy, retrying in 5 seconds..."
                debug 'DEBUG' "${TMP_DIR}${path} is busy, retrying in 5 seconds"
                sleep 5
              else
                debug 'DEBUG' "Unmounting subvolume $subvol in cleanup function: umount ${TMP_DIR}${path}"
                break
              fi
            done
          fi
        fi
      done

      # Root subvolume
      if [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR} " /proc/mounts; then
        while true; do
          if ! umount "${TMP_DIR}" && grep -qs "${TMP_DIR} " /proc/mounts; then
            echo -e "${Yellow}!! ${Green}${TMP_DIR} ${Yellow}is busy, retrying in 5 seconds..."
            debug 'DEBUG' "${TMP_DIR} is busy, retrying in 5 seconds"
            sleep 5
          else
            debug 'DEBUG' "Unmounting root subvolume (@) in cleanup function: umount ${TMP_DIR}"
            break
          fi
        done
      fi

    # All other filesystems
    else
      # Unmount img root
      if [ -n "$TMP_DIR" ] && grep -qs "$TMP_DIR " /proc/mounts; then
        while true; do
          if ! umount "${TMP_DIR}" && grep -qs "$TMP_DIR " /proc/mounts; then
            echo -e "${Yellow}!! ${Green}${TMP_DIR} ${Yellow}is busy, retrying in 5 seconds..."
            debug 'DEBUG' "${TMP_DIR} is busy, retrying in 5 seconds"
            sleep 5
          else
            debug 'DEBUG' "Unmounting root partition in cleanup function: umount ${TMP_DIR}"
            break
          fi
        done
      fi
    fi

    # Remove loop
    if losetup "$LOOP" &>/dev/null; then
      while true; do
        if ! losetup -d "$LOOP"; then
          echo -e "${Yellow}!! ${Green}${LOOP} ${Yellow}is busy, retrying in 5 seconds"
          debug 'DEBUG' "${LOOP} is busy, retrying in 5 seconds"
          sleep 5
        else
          debug 'DEBUG' "Removing loop in cleanup function: losetup -d $LOOP"
          break
        fi
      done
    fi

    # Remove temp directly
    if [ -d "$TMP_DIR" ]; then
      debug 'DEBUG' "Removing temp directory in cleanup function: rm -rf $TMP_DIR"
      rm -rf "$TMP_DIR"
    fi

    # Remove temp file
    if [ -f "$tmp_file" ]; then
      debug 'DEBUG' "Removing temp file in cleanup function: rm $tmp_file"
      rm "$tmp_file"
    fi

    echo -e "${White}## ${Green}Done."
    echo -e "${White}## ${IWhite}Elapsed time: ${Green}$(date -d@$SECONDS -u +%M.%S)${NC}"
    debug 'INFO' "Elapsed time: $(date -d@$SECONDS -u +%M.%S)"
    debug 'DEBUG' 'Exiting script'
  fi
  if [ "$DEBUG" = true ]; then
    echo '#####################################################################################' >> "$LOG_FILE"
  fi
}
trap cleanup EXIT SIGTERM
trap "exit 10" SIGINT



# Function to pause script execution and prompt for user input
function pause() {
  read -p "$*"
}
# Uncomment the following line to enable the pause function
#pause 'Press [any] key to continue...'



# Set default variables
unset diff_small
VERSION='1.4-beta'
INSTALL_METHOD='default'
PROMPTS=true
DEBUG=false
EXCLUDE_FILE=false
AUTOEXPAND=true
AUTORESIZE_RUN=false
UPDATE=false
if [ "$INSTALL_METHOD" = 'curl' ]; then
  LOG_FILE='/var/log/shrink-backup.log'
  EXCLUDE_FILE_LOCATION='/usr/local/etc/shrink-backup.conf'
  EXCLUDE_FILE_LOCATION_BTRFS='/usr/local/etc/shrink-backup_btrfs.conf'
else
  LOG_FILE="$(dirname $0)/shrink-backup.log"
  EXCLUDE_FILE_LOCATION="$(dirname $0)/exclude.txt"
  EXCLUDE_FILE_LOCATION_BTRFS="$(dirname $0)/exclude_btrfs.txt"
fi
AUTORESIZE_WARNING=false
ZOOM=false
LOOPRUN=false
CHROOTRUN=false
RSYNC_DELETE='--delete' # gets set to --delete-before if --fix is selected
RSYNC_TTY=true # gets set to false if -q|--quiet is selected
RSYNC_CUSTOM=false
F2FS_CONVERSION=false
BTRFS_CONVERSION=false
#STARTLINE="$0 $*" # will produce double // if script is in $PATH
STARTLINE="$(dirname $0)/$(basename $0) $*" # will produce absolute path if script is in $PATH
#STARTLINE="$(realpath $0) $*" # same as bove, but will ALWYAS produce absolute path

# If no TTY is available (for example running custom command in webmin)
if [ -t 0 ]; then
  TTY_AVAILABILITY='/dev/tty'

  # Colors
  White='\033[0;37m' # white
  IWhite='\033[0;97m' # high intensity white
  Red='\033[0;91m' # high intensity red
  Blue='\033[0;94m' # high intensity blue
  Green='\033[0;92m' # high intensity green
  Yellow='\033[0;93m' # high intensity yellow
  Purple='\033[0;95m' # high intensity purple
  NC='\033[0m' # Text Reset - No colors
  COLORS=true
else
  TTY_AVAILABILITY='/dev/null'
  COLORS=false
fi



# Print version and exit
version() {
  echo -e "${Purple}#########################################################################
#                                                                       #
# ${Green}shrink-backup version $VERSION                                        ${Purple}#
#                                                                       #
# ${IWhite}Copyright (c) 2024-present, Marcus Johansson                          ${Purple}#
# ${White}https://github.com/UnconnectedBedna/shrink-backup                     ${Purple}#
# ${White}All rights reserved.                                                  ${Purple}#
#                                                                       #
# ${White}This source code is licensed under the BSD-style license found in the ${Purple}#
# ${White}LICENSE file in the root directory of this source tree.               ${Purple}#
#                                                                       #
#########################################################################"
exit 2
}



# Display help information and exit
help() {
  local help
  read -r -d '' help << EOM
${IWhite}Script for creating an .img file and subsequently keeing it updated (-U), autoexpansion is enabled by default
Directory where .img file is created is automatically excluded in backup
######################################################################################################################
Usage: ${Green}sudo $(basename "$0") [options] imagefile.img [extra space (MiB)]
  -U             ${IWhite}Update existing img file (rsync to existing img)
                   Optional [extra space] extends img root partition
  ${Green}-a             ${IWhite}Autocalculate root size partition, [extra space] is ignored.
                   When used in combination with -U:
                   Expand if partition is >=256MiB smaller than autocalculated recommended minimum
                   Shrink if partition is >=512MiB bigger than autocalculated recommended minimum
  ${Green}-t             ${IWhite}Use exclude.txt in same folder as script to set excluded directories
                   One directory per line: "/dir" or "/dir/*" to only exclude contents
                   Wildcards work, f.ex "/dir*" will eclude all directories starting with "/dir"
  ${Green}-y             ${IWhite}Disable prompts in script (please use this option with care!)
  ${Green}-e             ${IWhite}Disable autoexpansion on root filesystem when image is booted
  ${Green}-l             ${IWhite}Write debug messages to logfile shrink-backup.log located in same directory as script
  ${Green}-z             ${IWhite}Make script zoom at light-speed, only question prompts might slow it down
                   Can be combined with -y for UNSAFE ultra-mega-superduper-speed
  ${Green}-q --quiet     ${IWhite}Do not print rsync copy process
  ${Green}--no-color     ${IWhite}Run script without color formatted text
  ${Green}--fix          ${IWhite}Try to fix the img file if -a fails with a "broken pipe" error
                   Will activate rsync options --delete-before & --fsync
  ${Green}--rsync        ${IWhite}Define custom rsync line manually. Will print rsync line for user to edit
  ${Green}--loop [img]   ${IWhite}Loop img file and exit, works in combination with -l & -z
                   If optional [extra space] is defined, the img file will be extended with the amount before looping
                   NOTE that only the file gets truncated, no partitions
                   Useful if you for example want to manually manage the partitions
  ${Green}--chroot [img] ${IWhite}Use systemd-nspawn. Loop img file, mount to temp directory, enter chroot environment and drop to shell
                   This will let you make changes in a chroot environment directly on the img file
                   For example update with package manager or rebuild initramfs
                   The script will keep running in the background
                   Type 'exit' when done. Script will unmount, remove temp directory/loop and exit
  ${Green}--f2fs         ${IWhite}Convert root filesystem on img from ext4 to f2fs
                   Only works on new img file, not in combination with -U
                   Will make backups of fstab & cmdline.txt to: fstab.shrink-backup.bak & cmdline.txt.shrink-backup.bak
                   Then change ext4 to f2fs in both files and add discard to options on root partition in fstab
  ${Green}--version      ${IWhite}Print version and exit
  ${Green}-h --help      ${IWhite}Show this help snippet
######################################################################################################################
Examples:
${Green}sudo $(basename "$0") -a /path/to/backup.img ${White}(create img, automatically set size)
${Green}sudo $(basename "$0") -e -y /path/to/backup.img 1024 ${White}(create img, ignore prompts, do NOT autoexpand, add 1024MiB extra space)
${Green}sudo $(basename "$0") -Utl /path/to/backup.img ${White}(update img backup, use exclude.txt and write log to shrink-backup.log)
${Green}sudo $(basename "$0") -U /path/to/backup.img 1024 ${White}(update img backup, expand img size/root partition with 1024MiB)
${Green}sudo $(basename "$0") -Ua /path/to/backup.img ${White}(update img backup, automatically resizes img file if needed)
${Green}sudo $(basename "$0") -Ua --fix /path/to/backup.img 1024 ${White}(update img backup, automatically resizes img file if needed, fix img free space)
${Green}sudo $(basename "$0") -l --loop /path/to/backup.img 1024 ${White}(write to log file, expand IMG FILE (not partition) by 1024MiB, loop then exit script)
EOM
  echo -e "$help"
  exit 2
}



# Parse command-line options
options=$(getopt -o Uatyelzhq --long help,version,quiet,fix,f2fs,no-color,rsync,loop,chroot: -- "$@")
[ $? -eq 0 ] || {
    echo -e "${Red}Invalid options provided"
    help
}
eval set -- "$options"
while true; do
  case "$1" in
    -h|--help) help; break;;
    --version) version; break;;
    -U) UPDATE=true; shift;;
    -a) AUTORESIZE_RUN=true; shift;;
    -t) EXCLUDE_FILE=true; shift;;
    -y) PROMPTS=false; shift;;
    -e) AUTOEXPAND=false; shift;;
    -l) DEBUG=true; shift;;
    -z) ZOOM=true; shift;;
    -q|--quiet) RSYNC_TTY=false; shift;;
    --fix) RSYNC_DELETE='--delete-before --fsync'; shift;;
    --f2fs) F2FS_CONVERSION=true; shift;;
    --no-color) unset White IWhite Red Blue Green Yellow Purple NC; COLORS=false; debug 'DEBUG' '--no-color selected by user, unsetting color variables'; shift;;
    --rsync) RSYNC_CUSTOM=true; shift;;
    --loop) LOOPRUN=true; IMG_FILE="$3"; shift;;
    --chroot) CHROOTRUN=true; IMG_FILE="$2"; shift;;
    --) break;;
    *) shift;;
  esac
done

# Process non-option arguments
while [ "$#" -gt 0 ]; do
  if [[ "$1" =~ ^- ]]; then
    shift
  # If --loop or --chroot is used, IMG_FILE is already set
  elif [ -n "$IMG_FILE" ]; then
    ADDED_SPACE="$2"
    break
  else
    IMG_FILE="$1"
    ADDED_SPACE="$2"
    break
  fi
done

# Set width
COLS=85
if [ $(echo "$IMG_FILE" | wc -m) -gt $(( COLS - 19 )) ]; then
  COLS=$(( $(echo "$IMG_FILE" | wc -m) + 20 ))
fi
if [ -t 0 ] && [ $(tput cols) -lt "$COLS" ]; then # tput will fail in webmin
  COLS=$(tput cols)
fi
BREAK="$(printf %${COLS}s | tr ' ' '#')"

# Verify script is running as root
if [ "$EUID" -ne 0 ]; then
  echo -e "${Red}!! THIS SCRIPT MUST BE RUNNING AS ROOT! (WITH SUDO)"
  help
fi



# loop img file and exit
function looprun() {
  debug 'DEBUG' "IMG_FILE=$IMG_FILE"
  debug 'DEBUG' "ADDED_SPACE=$ADDED_SPACE"
  if [ "$ADDED_SPACE" -ne 0 ]; then
    debug 'INFO' 'ADDED_SPACE not 0, truncating img file'
    if [ "$PROMPTS" = true ]; then
      echo -e "${Yellow}!! ${Red}WARNING! ${Yellow}You have requested to add ${Green}${ADDED_SPACE}MiB ${Yellow}to the img file (NOT partition)"
      debug 'INFO' 'Do you want to continue with the truncate operation? [y/n]'
      while true; do
        if [ "$COLORS" = true ]; then
          read -r -p $'\e[0;37m## \e[0;97mDo you want to continue with the truncate operation? \e[0;92m[y/n] \e[0m' input
        else
          read -r -p '## Do you want to continue with the truncate operation? [y/n] ' input
        fi
        case $input in
          [Yy]) break;;
          [Nn]) echo -e "${Red}!! Aborting..."; exit 4;;
          *) echo -e "${Yellow}!! ${Red}ERROR! ${Yellow}Please enter ${Green}'y' ${Yellow}or ${Green}'n'${Yellow}"; debug 'WARNING' "ERROR, please enter 'y' or 'n'";;
        esac
      done
      debug 'INFO' 'Y or y pressed to confirm'
      echo -e "${White}## ${IWhite}Truncating file by adding ${Green}${ADDED_SPACE}MiB"
      $SLEEPING
    else
      echo -e "${White}## ${IWhite}Truncating file by adding ${Green}${ADDED_SPACE}MiB"
      $SLEEPING
    fi
    debug 'DEBUG' "Running: truncate -s +\$(( $ADDED_SPACE * 1024 * 1024 )) $IMG_FILE"
    if ! output=$(truncate -s +$(( ADDED_SPACE * 1024 * 1024 )) "$IMG_FILE" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! TRUNCATE FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "TRUNCATE FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 1
    fi
  fi

  debug 'INFO' 'Running function: do_loop'
  do_loop

  echo -e "${White}## ${Green}$IMG_FILE ${IWhite}is looped to ${Green}$LOOP"
  echo -e "${Purple}$BREAK"
  readarray -t looprun_output < <(lsblk $LOOP)
  for i in "${looprun_output[@]}"; do
    #echo -e "${Purple}# ${Green}${i} ${Purple}$(printf "%+$(( COLS - 3 - $(echo ${i} | wc -m ) ))s" '#')"
    echo -e "${Purple}# ${Green}${i}"
  done
  echo -e "${Purple}$BREAK"
  echo -e "${White}## ${Green}Done."
  echo -e "${White}## ${IWhite}To remove loop, type: ${Green}sudo losetup -d ${LOOP}"
  debug 'DEBUG' 'Exiting script, exit 2'
  if [ "$DEBUG" = true ]; then
    echo '#####################################################################################' >> "$LOG_FILE"
  fi
exit 2
}



function chrootrun() {

  check_dependencies
  do_loop

  # Assumes last partition is root
  partprobe "$LOOP"
  sleep 2
  FSTYPE="$(lsblk -no fstype $LOOP | tail -1)"
  debug 'DEBUG' "FSTYPE=$FSTYPE"
  # First index (LSBLK_PARTITIONS[0]) will be the loop itself
  LSBLK_PARTITIONS=($(lsblk -no path $LOOP))
  debug 'DEBUG' "LSBLK_PARTITIONS=$(echo ${LSBLK_PARTITIONS[@]})"

  # Check for temp directory and create if needed
  if ! [ -d "$TMP_DIR" ]; then
    echo -e "${White}## ${IWhite}Creating temp directory..."
    $SLEEPING
    debug 'INFO' 'Creating temp directory'
    debug 'DEBUG' "Running: mktemp -d -t chroot-XXX"
    TMP_DIR=$(mktemp -d -t chroot-XXX)
    debug 'DEBUG' "TMP_DIR=$TMP_DIR"
  fi

  # ext4 or f2fs
  if [ "$FSTYPE" == 'ext4' ] || [ "$FSTYPE" == 'f2fs' ]; then
    # Assumes root is on last partition
    count=$(( ${#LSBLK_PARTITIONS[@]} - 1 )) # ${#LSBLK_PARTITIONS[@]} gives count, -1 removes device so only partitions are counted
    echo -e "${White}## ${IWhite}Mounting img ${Green}root (/) ${IWhite}partition"
    $SLEEPING
    debug 'INFO' 'Mounting img root partition'
    debug 'DEBUG' "Running: mount ${LSBLK_PARTITIONS[$count]} $TMP_DIR"
    if ! output=$(mount "${LSBLK_PARTITIONS[$count]}" "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! IMG ROOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "IMG ROOT MOUNT FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

    # Remount with flags from fstab
    fstab=($(cat "$TMP_DIR"/etc/fstab | grep ' / '))
    echo -e "${White}## ${IWhite}Remounting img ${Green}root (/) ${IWhite}partition with flags from fstab"
    $SLEEPING
    debug 'INFO' 'Remounting img root partition with flags from fstab'
    debug 'DEBUG' "Running: mount -o remount,${fstab[3]} $TMP_DIR"
    if ! output=$(mount -o remount,${fstab[3]} "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! REMOUNTING IMG ROOT PARTITION FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "REMOUNTING IMG ROOT PARTITION FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

    # Mount boot if exists
    if grep -q 'boot' $TMP_DIR/etc/fstab; then
      (( count -- ))
      debug 'INFO' 'Boot partition found in fstab, mounting img boot partition'
      fstab=($(cat "$TMP_DIR"/etc/fstab | grep 'boot'))
      echo -e "${White}## ${IWhite}Mounting img ${Green}${fstab[1]} ${IWhite}from fstab"
      $SLEEPING
      debug 'DEBUG' "Running: mount -o ${fstab[3]} ${LSBLK_PARTITIONS[$count]} ${TMP_DIR}${fstab[1]}"
      if ! output=$(mount -o "${fstab[3]}" "${LSBLK_PARTITIONS[$count]}" "${TMP_DIR}${fstab[1]}" 2>&1); then
        echo -e "${Yellow}$output\n${Red}!! IMG BOOT MOUNT FAILED!!!"
        debug 'BREAK'
        debug 'ERROR' "IMG BOOT MOUNT FAILED:\n$output\n-------------------------------------------------------------------------------------"
        exit 3
      fi
    fi

  # btrfs
  elif [ "$FSTYPE" == 'btrfs' ]; then
    # Assumes root subvolume is @ and is on second partition
    echo -e "${White}## ${IWhite}Mounting img ${Green}@ ${IWhite}subvolume"
    $SLEEPING
    debug 'INFO' 'Mounting img @ subvolume'
    debug 'DEBUG' "Running: mount -o subvol=@ ${LSBLK_PARTITIONS[2]} $TMP_DIR"
    if ! output=$(mount -o subvol=@ "${LSBLK_PARTITIONS[2]}" "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! IMG ROOT SUBVOLUME (@) MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "IMG ROOT SUBVOLUME (@) MOUNT FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

    # Remount with flags from fstab
    fstab=($(cat "$TMP_DIR"/etc/fstab | grep ' / '))
    echo -e "${White}## ${IWhite}Remounting img ${Green}@ ${IWhite}subvolume with flags from fstab"
    $SLEEPING
    debug 'INFO' 'Remounting img @ subvolume with flags from fstab'
    debug 'DEBUG' "Running: mount -o remount,${fstab[3]} $TMP_DIR"
    if ! output=$(mount -o remount,${fstab[3]} "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! REMOUNTING IMG ROOT SUBVOLUME (@) FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "REMOUNTING IMG ROOT SUBVOLUME (@) FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

    # Assumes boot exists and is on first partition
    fstab=($(cat "$TMP_DIR"/etc/fstab | grep 'boot'))
    debug 'INFO' 'Mounting img boot partition'
    echo -e "${White}## ${IWhite}Mounting img ${Green}${fstab[1]} ${IWhite}from fstab"
    $SLEEPING
    debug 'DEBUG' "Running: mount -o ${fstab[3]} ${LSBLK_PARTITIONS[1]} ${TMP_DIR}${fstab[1]}"
    if ! output=$(mount -o "${fstab[3]}" "${LSBLK_PARTITIONS[1]}" "${TMP_DIR}${fstab[1]}" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! IMG BOOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "IMG BOOT MOUNT FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

    # Filter out @ and subvolumes not in fstab
    IMG_SUBVOLUMES=($(btrfs subvol list $TMP_DIR | awk '{print $9}'))
    echo -e "${White}## ${IWhite}Subvolumes found on img ${Green}${IMG_SUBVOLUMES[@]}"
    echo -e "${White}## ${IWhite}Filtering out subvolumes not present in fstab"
    $SLEEPING
    debug 'INFO' 'Filtering out @ and subvolumes not in fstab'
    debug 'DEBUG' "Subvolumes before filtering: $(echo ${IMG_SUBVOLUMES[@]})"
    for i in ${!IMG_SUBVOLUMES[@]}; do
      if ! $(grep -q ${IMG_SUBVOLUMES[i]} $TMP_DIR/etc/fstab) || [ $(echo ${IMG_SUBVOLUMES[i]}) == '@' ]; then
      unset IMG_SUBVOLUMES[i]
      fi
    done
    echo -e "${White}## ${IWhite}Subvolumes to mount: ${Green}${IMG_SUBVOLUMES[@]}"
    $SLEEPING
    debug 'DEBUG' "Subvolumes after filtering: ${IMG_SUBVOLUMES[@]}"
    # Mount remaining subvolumes
    debug 'INFO' 'Mounting remaining subvolumes'
    for subvol in ${IMG_SUBVOLUMES[@]}; do
      fstab=($(cat "$TMP_DIR"/etc/fstab | grep "$subvol"))
      echo -e "${White}## ${IWhite}Mounting img ${Green}${fstab[1]} ${IWhite}from fstab"
      $SLEEPING
      debug 'DEBUG' "Running: mount -o ${fstab[3]} ${LSBLK_PARTITIONS[2]} ${TMP_DIR}${fstab[1]}"
      if ! output=$(mount -o "${fstab[3]}" "${LSBLK_PARTITIONS[2]}" "${TMP_DIR}${fstab[1]}" 2>&1); then
        echo -e "${Yellow}$output\n${Red}!! SUBVOLUME MOUNT FAILED!!!"
        debug 'BREAK'
        debug 'ERROR' "IMG SUBVOLUME MOUNT FAILED:\n$output\n-------------------------------------------------------------------------------------"
        exit 3
      fi
    done
  fi

  # Enter chroot environment
  echo -e "${White}## ${IWhite}Running systemd-nspawn, type ${Green}exit ${IWhite}when done to exit chroot environment"
  echo -e "${White}## ${Yellow}YOU ARE RUNNING AS ROOT!!!${NC}"
  if systemctl is-active -q systemd-resolved.service; then
    debug 'DEBUG' "systemd-resolved.service is active, running: systemd-nspawn --resolv-conf=replace-stub -D $TMP_DIR bin/bash"
    systemd-nspawn --resolv-conf=replace-stub -D "$TMP_DIR" bin/bash
  else
    debug 'DEBUG' "systemd-resolved.service is not active, running: systemd-nspawn --resolv-conf=copy-host -D $TMP_DIR bin/bash"
    systemd-nspawn --resolv-conf=copy-host -D "$TMP_DIR" bin/bash
  fi
exit 0
}



# Gather device information
function dev_variables() {

  ADDED_SPACE=$(( ADDED_SPACE * 1024 * 1024 )) # bytes, ADDED_SPACE=0 if AUTORESIZE_RUN=true

  # Check if separate boot and root partition exists and set variables accordingly
  if grep -q 'boot' /etc/fstab; then
    BOOT_PARTITION=true
    LOCAL_DEV_BOOT_PATH=$(mount --fake | grep 'boot' | awk '{print $1}')
    LOCAL_DEV_ROOT_PATH=$(mount --fake | grep ' / ' | awk '{print $1}')
    debug 'DEBUG' "BOOT_PARTITION=$BOOT_PARTITION | LOCAL_DEV_BOOT_PATH=$LOCAL_DEV_BOOT_PATH | LOCAL_DEV_ROOT_PATH=$LOCAL_DEV_ROOT_PATH"
    LOCAL_BOOT_UUID=$(lsblk -no uuid "$LOCAL_DEV_BOOT_PATH")
    LOCAL_ROOT_UUID=$(lsblk -no uuid "$LOCAL_DEV_ROOT_PATH")
    LOCAL_ROOT_PARTUUID=$(lsblk -no partuuid "$LOCAL_DEV_ROOT_PATH")
    debug 'DEBUG' "LOCAL_BOOT_UUID=$LOCAL_BOOT_UUID | LOCAL_ROOT_UUID=$LOCAL_ROOT_UUID | LOCAL_ROOT_PARTUUID=$LOCAL_ROOT_PARTUUID"
  else
    debug 'INFO' 'No boot partition detected'
    BOOT_PARTITION=false
    LOCAL_DEV_ROOT_PATH=$(mount --fake | grep ' / ' | awk '{print $1}')
    debug 'DEBUG' "BOOT_PARTITION=$BOOT_PARTITION | LOCAL_DEV_ROOT_PATH=$LOCAL_DEV_ROOT_PATH"
    LOCAL_ROOT_UUID=$(lsblk -no uuid "$LOCAL_DEV_ROOT_PATH")
    LOCAL_ROOT_PARTUUID=$(lsblk -no partuuid "$LOCAL_DEV_ROOT_PATH")
    debug 'DEBUG' "LOCAL_ROOT_UUID=$LOCAL_ROOT_UUID | LOCAL_ROOT_PARTUUID=$LOCAL_ROOT_PARTUUID"
  fi
  LOCAL_ROOT_PARTN=$(blkid -s PART_ENTRY_NUMBER -o value -p "$LOCAL_DEV_ROOT_PATH")
  #LOCAL_ROOT_PARTN=$(parted -sm "$LOCAL_DEV_PATH" print | tail -1 | cut -d : -f 1)
  debug 'DEBUG' "LOCAL_ROOT_PARTN=$LOCAL_ROOT_PARTN"

  # Collect information about partition sizes
  debug 'INFO' 'Calculating size for dd to cover bootsector and adding 5MiB (5242880 bytes) to overlap into root (only used in img creation)'
  #LOCAL_BOOTSECTOR=$(lsblk --bytes -no size "$LOCAL_DEV_BOOT_PATH") # bytes, can not be used, will be 0 if no boot partition exists
  LOCAL_ROOT_START=$(fdisk -lo device,start "$LOCAL_DEV_PATH" | grep "$LOCAL_DEV_ROOT_PATH" | awk '{print $2}') # 512B blocks
  LOCAL_BOOTSECTOR=$(( LOCAL_ROOT_START - 1 )) # blocks, to set the actual bootsector, needed in case no boot partition exists
  LOCAL_ROOT_START=$(( LOCAL_ROOT_START * 512 )) # bytes
  LOCAL_BOOTSECTOR=$(( LOCAL_BOOTSECTOR * 512 )) # bytes
  LOCAL_DDBOOTSECTOR=$(( (LOCAL_BOOTSECTOR + 5242880) / 512 )) # 512B blocks, 5242880 = 5MiB in bytes
  debug 'DEBUG' "LOCAL_ROOT_START=$LOCAL_ROOT_START bytes | LOCAL_BOOTSECTOR=$LOCAL_BOOTSECTOR bytes | LOCAL_DDBOOTSECTOR=$LOCAL_DDBOOTSECTOR 512B blocks"

  # Set automated calculated size (btrfs_variables if btrfs filesystem)
  if [ "$AUTORESIZE_RUN" = true ] || [ "$UPDATE" = false ] || [ "$FSTYPE" == 'btrfs' ]; then
    debug 'INFO' 'Calculating recommended root size'
    BLOCKSIZE=$(stat -fc %s /) # bytes
    debug 'DEBUG' "BLOCKSIZE=${BLOCKSIZE} bytes"
    if [ "$FSTYPE" == 'ext4' ]; then
      debug 'INFO' 'ext4 filesystem detected, using resize2fs to set recommended root size'
      LOCAL_AUTORESIZE_MIN=$(resize2fs -P "$LOCAL_DEV_ROOT_PATH" 2>/dev/null | awk '{print $7}') # blocks
      LOCAL_AUTORESIZE_MIN=$(( LOCAL_AUTORESIZE_MIN * BLOCKSIZE )) # bytes
      debug 'DEBUG' "LOCAL_AUTORESIZE_MIN=${LOCAL_AUTORESIZE_MIN} bytes"
    elif [ "$FSTYPE" == 'f2fs' ]; then
      # Method 2, using "used space" straight up
      debug 'INFO' 'f2fs filesystem detected, using df (+512MiB) to set recommended root size'
      LOCAL_AUTORESIZE_DF=$(df / -k --sync --output=used | tail -1) # 1k blocks
      LOCAL_AUTORESIZE_MIN=$(( LOCAL_AUTORESIZE_DF * 1024 )) # bytes
      LOCAL_AUTORESIZE_MIN=$(( LOCAL_AUTORESIZE_MIN + 536870912 )) # adding 512MiB
      debug 'DEBUG' "LOCAL_AUTORESIZE_MIN=${LOCAL_AUTORESIZE_MIN} bytes"
    elif [ "$FSTYPE" == 'btrfs' ]; then
      debug 'INFO' 'Running function: btrfs_variables'
      btrfs_variables
    fi
  fi

  # Method 1, using the value of "size - available"
  #declare -a LOCAL_DF_OUTPUT=( $(df / -k --sync --output=size,avail | tail -1) ) # 1k blocks
  #LOCAL_USED_SPACE=$(( (${LOCAL_DF_OUTPUT[0]} - ${LOCAL_DF_OUTPUT[1]}) * 1024 )) # bytes, df is in 1k blocks, 0 is the first position in an array

  # Method 2, using "used space" straight up
  if [ "$FSTYPE" != 'btrfs' ]; then
    LOCAL_DF_OUTPUT=$(df / -k --sync --output=used | tail -1) # 1k blocks
    LOCAL_USED_SPACE=$(( LOCAL_DF_OUTPUT * 1024 )) # bytes, df is in 1k blocks
  fi

  # Method 3, using du
  #LOCAL_USED_SPACE=$(du -xsb / | awk '{print $1}') # bytes

  # Set recommended size if option is selected
  if [ "$AUTORESIZE_RUN" = true ]; then
    debug 'INFO' 'Setting TOTAL (space needed for files on root) to autocalculated size'
    TOTAL=$LOCAL_AUTORESIZE_MIN # bytes
    # Add 512MiB if f2fs conversion
    if [ "$F2FS_CONVERSION" = true ]; then
      debug 'INFO' 'Adding 512MiB because of f2fs conversion'
      TOTAL=$(( $TOTAL + 536870912 ))
    fi
  else
    debug 'INFO' 'Calculating TOTAL (space needed for files on root) by adding LOCAL_USED_SPACE and ADDED_SPACE'
    debug 'DEBUG' "LOCAL_USED_SPACE=${LOCAL_USED_SPACE} bytes | ADDED_SPACE=${ADDED_SPACE} bytes"
    TOTAL=$(( LOCAL_USED_SPACE + ADDED_SPACE )) # bytes
  fi
  debug 'DEBUG' "TOTAL=${TOTAL} bytes"
  TRUNCATE_TOTAL=$(( LOCAL_BOOTSECTOR + TOTAL )) # bytes
  debug 'INFO' 'Calculating .img file size by adding LOCAL_BOOTSECTOR to TOTAL'
  debug 'DEBUG' "TRUNCATE_TOTAL=${TRUNCATE_TOTAL} bytes"

  # Add 128MiB extra space if autocalculated size reports bigger minimum than created on new img
  if [ "$UPDATE" = false ] && [ "$TOTAL" -lt "$LOCAL_AUTORESIZE_MIN" ]; then
    debug 'WARNING' 'Adding WIGGLEROOM (128MiB) because manually requested ADDED_SPACE is less than autocaluclated size'
    AUTORESIZE_WARNING=true
    WIGGLEROOM=134217728 # 128MiB = 134217728B, 192MiB = 201326592B
    TRUNCATE_TOTAL=$(( TRUNCATE_TOTAL + WIGGLEROOM ))
    debug 'DEBUG' "AUTORESIZE_WARNING=$AUTORESIZE_WARNING | WIGGLEROOM=${WIGGLEROOM} bytes | TRUNCATE_TOTAL=${TRUNCATE_TOTAL} bytes"
  fi
return 0
}



# Gather btrfs information
function btrfs_variables() {

  debug 'INFO' 'Using btrfs fi us to get required size'
  declare -a BTRFS_USAGE=($(btrfs fi us -T --raw / | tail -1)) # bytes
  LOCAL_USED_SPACE=$(( BTRFS_USAGE[1] + BTRFS_USAGE[2] + BTRFS_USAGE[3] )) # adding Data single, Metadata single & System single
  debug 'DEBUG' "LOCAL_USED_SPACE=$LOCAL_USED_SPACE"
  if [ "$AUTORESIZE_RUN" = true ]; then
    debug 'INFO' 'Adding 512MiB to LOCAL_USED_SPACE as recommended minimum size'
    LOCAL_AUTORESIZE_MIN=$(( LOCAL_USED_SPACE + 536870912 ))
    debug 'DEBUG' "LOCAL_AUTORESIZE_MIN=$LOCAL_AUTORESIZE_MIN bytes"
  fi

  # Get subvolumes
  debug 'DEBUG' "Running: btrfs subvolume list / | grep ' 5 ' | awk '{print \$9}'"
  declare -ag LOCAL_TOP_SUBVOLUMES=( $(btrfs subvolume list / | grep ' 5 ' | awk '{print $9}') ) # -g = make variable global
  debug 'DEBUG' "LOCAL_TOP_SUBVOLUMES=$(echo ${LOCAL_TOP_SUBVOLUMES[@]})"
  debug 'DEBUG' "Running: btrfs subvolume list / --sort=path | grep -v ' 5 ' | awk '{print \$9}'"
  declare -ag LOCAL_NESTED_SUBVOLUMES=( $(btrfs subvolume list / --sort=path | grep -v ' 5 ' | awk '{print $9}') )
  debug 'DEBUG' "LOCAL_NESTED_SUBVOLUMES=$(echo ${LOCAL_NESTED_SUBVOLUMES[@]})"

  # Filter out top subvolumes not in fstab
  debug 'INFO' 'Filtering out top level 5 subvolumes not existing in fstab'
  for i in ${!LOCAL_TOP_SUBVOLUMES[@]}; do
    subvol=${LOCAL_TOP_SUBVOLUMES[i]}
    if $(echo $subvol | grep -q -v -f /etc/fstab); then
      debug 'DEBUG' "Filtering out subvolume: $subvol"
      unset LOCAL_TOP_SUBVOLUMES[i]
    fi
  done
  debug 'DEBUG' "After filtering: LOCAL_TOP_SUBVOLUMES=$(echo ${LOCAL_TOP_SUBVOLUMES[@]})"

  # Filter out top subvolumes from exclude_btrfs.txt or shrink-backup_btrfs.conf
  if [ -f "$EXCLUDE_FILE_LOCATION_BTRFS" ]; then
    debug 'INFO' 'Filtering out top level 5 subvolumes to exclude from exclude_btrfs.txt or shrink-backup_btrfs.conf'
    for i in ${!LOCAL_TOP_SUBVOLUMES[@]}; do
      subvol=${LOCAL_TOP_SUBVOLUMES[i]}
      if $(echo $subvol | grep -q -f "$EXCLUDE_FILE_LOCATION_BTRFS"); then
        SUBVOLUME_EXCLUDE_PATHS+=( $(cat /etc/fstab | grep $subvol | awk 'print $2') )
        debug 'DEBUG' "Adding $(cat /etc/fstab | grep $subvol | awk 'print $2') to SUBVOLUME_EXCLUDE_PATHS"
        debug 'DEBUG' "Filtering out subvolume: $subvol"
        unset LOCAL_TOP_SUBVOLUMES[i]
      fi
    done
    debug 'DEBUG' "After filtering: LOCAL_TOP_SUBVOLUMES=$(echo ${LOCAL_TOP_SUBVOLUMES[@]})"

    # Filter out nested subvolumes from exclude_btrfs.txt or shrink-backup_btrfs.conf
    debug 'INFO' 'Filtering out nested subvolumes to exclude from exclude_btrfs.txt or shrink-backup_btrfs.conf'
    for i in ${!LOCAL_NESTED_SUBVOLUMES[@]}; do
      subvol=${LOCAL_NESTED_SUBVOLUMES[i]}
      if $(echo $subvol | grep -qxE -f "$EXCLUDE_FILE_LOCATION_BTRFS"); then
        debug 'DEBUG' "Filtering out subvolume: $subvol"

        # Fix path if nested subvolume is in other location than root subvolume
        top_subvolumes="$(echo ${LOCAL_TOP_SUBVOLUMES[@]} | sed 's/ /|/g')" # convert spaces into |
        if echo "$subvol" | grep -qE "$top_subvolumes"; then
          debug 'INFO' 'Nested volume not under root, fixing path'
          for top_subvol in ${LOCAL_TOP_SUBVOLUMES[@]}; do
            if echo "$subvol" | grep -qw "$top_subvol"; then
              break
            fi
          done
          path="$(cat /etc/fstab | grep $top_subvol | awk '{print $2}')"
          subvol="$(echo $subvol | sed "s|$top_subvol|$path|g")"
        fi
        if [[ "$subvol" != /* ]]; then
          subvol="/$subvol"
        fi
        debug 'DEBUG' "Adding $subvol to SUBVOLUME_EXCLUDE_PATHS"
        SUBVOLUME_EXCLUDE_PATHS+=($subvol)
        unset LOCAL_NESTED_SUBVOLUMES[i]
      fi
    done
    if [ -n "$SUBVOLUME_EXCLUDE_PATHS" ]; then
      SUBVOLUME_EXCLUDE_PATHS="$(echo ${SUBVOLUME_EXCLUDE_PATHS[@]} | sed 's/ /,/g')"
      debug 'DEBUG' "SUBVOLUME_EXCLUDE_PATHS=$SUBVOLUME_EXCLUDE_PATHS)"
    fi
    debug 'DEBUG' "After filtering: LOCAL_NESTED_SUBVOLUMES=$(echo ${LOCAL_NESTED_SUBVOLUMES[@]})"
  fi
return 0
}



# Gather image information
function img_variables() {

  if [ "$UPDATE" = true ]; then
    debug 'DEBUG' "Running: stat -c %s $IMG_FILE"
    IMG_SIZE=$(stat -c %s "$IMG_FILE")
    debug 'DEBUG' "IMG_SIZE=$IMG_SIZE bytes"
  fi

  # Boot partition exists
  if grep -q 'boot' /etc/fstab; then

    # ext4 & f2fs
    if [ "$FSTYPE" == 'ext4' ] || [ "$FSTYPE" == 'f2fs' ]; then
      # I have no idea why, but if I do not put this sleep here, IMG_DEV_ROOT_PATH does not get set
      sleep 2
      #pause 'Press [Enter] key to continue...'
      IMG_DEV_BOOT_PATH=$(lsblk -no path,uuid "$LOOP" | grep "$LOCAL_BOOT_UUID" | awk '{print $1}')
      IMG_DEV_ROOT_PATH=$(lsblk -no path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
      debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
      # 2s sleep is sometimes not enough, might have to do with slow network if img file is on a network share
      if ! [ -e "$IMG_DEV_BOOT_PATH" ] || ! [ -e "$IMG_DEV_ROOT_PATH" ]; then
        for (( i=1; i<=3; i++ )); do
          echo -e "${Yellow}!! ${Yellow}LOOP paths can not be set, retrying in 5 seconds..."
          debug 'WARNING' 'LOOP paths can not be set, retrying in 5 seconds'
          debug 'WARNING' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
          sleep 5
          IMG_DEV_BOOT_PATH=$(lsblk -no path,uuid "$LOOP" | grep "$LOCAL_BOOT_UUID" | awk '{print $1}')
          IMG_DEV_ROOT_PATH=$(lsblk -no path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
          if [ -e "$IMG_DEV_BOOT_PATH" ] && [ -e "$IMG_DEV_ROOT_PATH" ]; then
            echo -e "${White}## ${Green}LOOP paths found, resuming backup..."
            debug 'INFO' "LOOP paths found, resuming backup"
            debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
            break
          fi
        done
      fi

      if ! [ -e "$IMG_DEV_BOOT_PATH" ] || ! [ -e "$IMG_DEV_ROOT_PATH" ]; then
        echo -e "${Red}!! LOOP PATHS CAN NOT BE SET!!!"
        debug 'ERROR' 'LOOP PATHS CAN NOT BE SET'
        exit 3
      fi

    # btrfs (old method)
    elif [ "$FSTYPE" == 'btrfs' ]; then
      IMG_DEV_BOOT_PATH="${LOOP}p1"
      IMG_DEV_ROOT_PATH="${LOOP}p2"
      debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
    fi

  # No boot partition exists
  else
    # I have no idea why, but if I do not put this sleep here, IMG_DEV_ROOT_PATH does not get set
    sleep 2
    #pause 'Press [Enter] key to continue...'
    IMG_DEV_ROOT_PATH=$(lsblk -no path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
    debug 'DEBUG' "IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
    # 2s sleep is sometimes not enough, might have to do with slow network if img file is on a network share
    if ! [ -e "$IMG_DEV_ROOT_PATH" ]; then
      for (( i=1; i<=3; i++ )); do
        echo -e "${Yellow}!! ${Yellow}LOOP paths can not be set, retrying in 5 seconds..."
        debug 'WARNING' 'LOOP paths can not be set, retrying in 5 seconds'
        debug 'WARNING' "IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
        sleep 5
        IMG_DEV_ROOT_PATH=$(lsblk -no path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
        if [ -e "$IMG_DEV_ROOT_PATH" ]; then
          echo -e "${White}## ${Green}LOOP paths found, resuming backup..."
          debug 'INFO' "LOOP paths found, resuming backup"
          debug 'DEBUG' "IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
          break
        fi
      done
    fi

    if ! [ -e "$IMG_DEV_ROOT_PATH" ]; then
      echo -e "${Red}!! LOOP PATHS CAN NOT BE SET!!!"
      debug 'ERROR' 'LOOP PATHS CAN NOT BE SET'
      exit 3
    fi
  fi
return 0
}



# Set default RSYNC_LINE
function rsync_line() {

  IMG_PATH=$(dirname "$IMG_FILE")
  debug 'INFO' 'Creating temp directory'
  debug 'DEBUG' "Running: mktemp -d -t backup-XXX"
  TMP_DIR=$(mktemp -d -t backup-XXX)
  debug 'DEBUG' "TMP_DIR=$TMP_DIR"
  debug 'INFO' 'Creating temp file to store rsync output'
  debug 'DEBUG' 'Running: mktemp -t rsync-XXX'
  tmp_file=$(mktemp -t rsync-XXX)
  debug 'DEBUG' "tmp_file=$tmp_file"
  if [ "$RSYNC_TTY" = false ]; then
    RSYNC_PATHS="/ $TMP_DIR 2>&1 | tee /dev/null > $tmp_file"
  else
    RSYNC_PATHS="/ $TMP_DIR 2>&1 | tee $TTY_AVAILABILITY > $tmp_file"
  fi
  debug 'DEBUG' "RSYNC_PATHS=$RSYNC_PATHS"

  if [ "$EXCLUDE_FILE" = true ]; then
    RSYNC_LINE="rsync -ahvHAX --exclude-from=$EXCLUDE_FILE_LOCATION --exclude={${IMG_PATH}/*,${TMP_DIR},${tmp_file},${BOOT_PATH}/shrink-backup.lock${SUBVOLUME_EXCLUDE_PATHS}} --info=progress2 --stats $RSYNC_DELETE --force --partial --delete-excluded --timeout=30"
  else
    RSYNC_LINE="rsync -ahvHAX --exclude={/lost+found,/proc/*,/sys/*,/dev/*,/tmp/*,/run/*,/mnt/*,/media/*,/var/swap,/snap/*,${IMG_PATH}/*,${BOOT_PATH}/shrink-backup.lock${SUBVOLUME_EXCLUDE_PATHS}} --info=progress2 --stats $RSYNC_DELETE --force --partial --delete-excluded --timeout=30"
  fi
  debug 'DEBUG' "RSYNC_LINE=$RSYNC_LINE"

  # If --rsync is selected, ask for user configuration
  if [ "$RSYNC_CUSTOM" = true ]; then
    echo -e "${Yellow}## Custom rsync line option selected"
    echo -e "${White}## ${IWhite}Default rsync line: ${Green}${RSYNC_LINE}"
    echo -e "${White}## ${IWhite}Edit line to use in script ${Yellow}(press ctrl+c to abort)${NC}"
    printf %${COLUMNS}s | tr ' ' '#'

    read -e -i "$RSYNC_LINE" input
    RSYNC_CUSTOM_LINE="$input"
    RSYNC_LINE="$input"
    debug 'DEBUG' "RSYNC_CUSTOM_LINE=$RSYNC_CUSTOM_LINE"
  fi

  # Add RSYNC_PATHS to RSYNC_LINE
  debug 'INFO' 'Combining RSYNC_LINE & RSYNC_PATHS'
  RSYNC_LINE="$(echo -e $RSYNC_LINE $RSYNC_PATHS)"
  debug 'DEBUG' "RSYNC_LINE=$RSYNC_LINE"
return 0
}



# Check for required dependencies
function check_dependencies() {

  # GPT
  if [ "$PARTITION_TABLE" == 'gpt' ]; then
    echo -e "${White}## ${Green}GPT partition table detected, ${Yellow}sgdisk needed, ${IWhite}checking for application..."
    $SLEEPING
    if ! command -v sgdisk > /dev/null 2>&1; then
      echo -e "${Yellow}!! sgdisk is NOT installed..."
      debug 'INFO' 'sgdisk not available on system'

      # Debian based
      if command -v apt > /dev/null 2>&1; then
        echo -e "${White}## ${Green}apt found, ${IWhite}trying to install gdisk..."
        # Confirm with user input
        if [ "$PROMPTS" = true ]; then
          debug 'INFO' 'Do you want to use apt to install gdisk? (will upgrade system first) [y/n]'
          while true; do
            if [ "$COLORS" = true ]; then
              read -r -p $'\e[0;37m## \e[0;93mDo you want to use apt to install gdisk? \e[0;97m(will upgrade system first) \e[0;92m[y/n] \e[0m' input
            else
              read -r -p '## Do you want to use apt to install gdisk? (will upgrade system first) [y/n] ' input
            fi
            case $input in
              [Yy]) break;;
              [Nn]) echo -e "${Red}!! Aborting..."; exit 4;;
              *) echo -e "${Yellow}!! ${Red}ERROR! ${Yellow}Please enter ${Green}'y' ${Yellow}or ${Green}'n'${Yellow}"; debug 'WARNING' "ERROR, please enter 'y' or 'n'";;
            esac
          done
          debug 'INFO' 'Y or y pressed to confirm'
          debug 'BREAK'
          debug 'DEBUG' 'Running: apt update -y && apt upgrade -y && apt install gdisk -y'
          apt update -y && apt upgrade -y && apt install gdisk -y
        else
          debug 'DEBUG' 'Running: apt update -y && apt upgrade -y && apt install gdisk -y'
          apt update -y && apt upgrade -y && apt install gdisk -y
        fi

      # Arch based
      elif command -v pacman > /dev/null 2>&1; then
        echo -e "${White}## ${Green}pacman found, ${IWhite}trying to install gdisk..."
        # Confirm with user input
        if [ "$PROMPTS" = true ]; then
          debug 'INFO' 'Do you want to use pacman to install gptfdisk? (will run pacman -Syu first) [y/n]'
          while true; do
            if [ "$COLORS" = true ]; then
              read -r -p $'\e[0;37m## \e[0;93mDo you want to use pacman to install gptfdisk? \e[0;97m(will run pacman -Syu first) \e[0;92m[y/n] \e[0m' input
            else
              read -r -p '## Do you want to use pacman to install gptfdisk? (will run pacman -Syu first) [y/n] ' input
            fi
            case $input in
              [Yy]) break;;
              [Nn]) echo -e "${Red}!! Aborting..."; exit 4;;
              *) echo -e "${Yellow}!! ${Red}ERROR! ${Yellow}Please enter ${Green}'y' ${Yellow}or ${Green}'n'${Yellow}"; debug 'WARNING' "ERROR, please enter 'y' or 'n'";;
            esac
          done
          debug 'INFO' 'Y or y pressed to confirm'
          debug 'BREAK'
          debug 'DEBUG' 'Running: pacman -Syu --nocofirm && pacman -S --noconfirm gptfdisk'
          pacman -Syu --noconfirm && pacman -S --noconfirm gptfdisk
        else
          debug 'DEBUG' 'Running: pacman -Syu --nocofirm && pacman -S --noconfirm gptfdisk'
          pacman -Syu --noconfirm && pacman -S --noconfirm gptfdisk
        fi

      # Installation failed or neither apt nor pacman is available
      else
        echo -e "${Red}!! Error! ${Yellow}Installing sgdisk failed! ${Green}Please install sgdisk manually and retry script..."
        debug 'ERROR' 'Installing sgdisk failed, aborting exit 3'
        echo -e "${Red}!! Aborting..."
        exit 3
      fi
      echo -e "${White}## ${Green}sgdisk installed successfully, ${IWhite}resuming backup..."
      debug 'INFO' 'gdisk installed successfully'
      $SLEEPING

    # sgdisk already installed
    else
      echo -e "${White}## ${Green}sgdisk is available, ${IWhite}resuming backup..."
      debug 'INFO' 'sgdisk is available on system'
      $SLEEPING
    fi
  fi

  # f2fs conversion (only apt)
  if [ "$F2FS_CONVERSION" = true ]; then
    echo -e "${White}## ${Green}--f2fs option selected, mkfs.f2fs is needed, ${IWhite}checking for application..."
    $SLEEPING
    if ! command -v mkfs.f2fs > /dev/null 2>&1; then
      echo -e "${Yellow}!! mkfs.f2fs is NOT installed..."
      debug 'INFO' 'mkfs.f2fs (f2fs-tools) not available on system'

      # Debian based
      if command -v apt > /dev/null 2>&1; then
        echo -e "${White}## ${Green}apt found, ${IWhite}trying to install f2fs-tools..."
        # Confirm with user input
        if [ "$PROMPTS" = true ]; then
          debug 'INFO' 'Do you want to use apt to install f2fs-tools? (will upgrade system first) [y/n]'
          while true; do
            if [ "$COLORS" = true ]; then
              read -r -p $'\e[0;37m## \e[0;93mDo you want to use apt to install f2fs-tools? \e[0;97m(will upgrade system first) \e[0;92m[y/n] \e[0m' input
            else
              read -r -p '## Do you want to use apt to install f2fs-tools? (will upgrade system first) [y/n] ' input
            fi
            case $input in
              [Yy]) break;;
              [Nn]) echo -e "${Red}!! Aborting..."; exit 4;;
              *) echo -e "${Yellow}!! ${Red}ERROR! ${Yellow}Please enter ${Green}'y' ${Yellow}or ${Green}'n'${Yellow}"; debug 'WARNING' "ERROR, please enter 'y' or 'n'";;
            esac
          done
          debug 'INFO' 'Y or y pressed to confirm'
          debug 'BREAK'
          debug 'DEBUG' 'Running: apt update -y && apt upgrade -y && apt install f2fs-tools -y'
          apt update -y && apt upgrade -y && apt install f2fs-tools -y
        else
          debug 'DEBUG' 'Running: apt update -y && apt upgrade -y && apt install f2fs-tools -y'
          apt update -y && apt upgrade -y && apt install f2fs-tools -y
        fi

      # Installation failed
      else
        echo -e "${Red}!! Error! ${Yellow}Installing mkfs.f2fs (f2fs-tools) failed! ${Green}Please install f2fs-tools manually and retry script..."
        debug 'ERROR' 'Installing f2fs-tools failed, aborting exit 3'
        echo -e "${Red}!! Aborting..."
        exit 3
      fi

    # mkfs.f2fs already installed
    else
      echo -e "${White}## ${Green}mkfs.f2fs is available, ${IWhite}resuming backup..."
      debug 'INFO' 'mkfs.f2fs is available on system'
      $SLEEPING
    fi
  fi

  # btrfs conversion (work in progress)
  if [ "$BTRFS_CONVERSION" = true ]; then
    echo 'btrfs'
  fi

  # --chroot selected (only apt)
  if [ "$CHROOTRUN" = true ]; then
    echo -e "${White}## ${Green}--chrootrun ${IWhite}selected, ${Yellow}systemd-nspawn needed, ${IWhite}checking for application..."
    $SLEEPING
    if ! command -v systemd-nspawn > /dev/null 2>&1; then
      echo -e "${Yellow}!! systemd-nspawn is NOT installed..."
      debug 'INFO' 'systemd-nspawn not available on system'

      # Only needed on debian based systems, on arch systemd-nspawn is in systemd package
      if command -v apt > /dev/null 2>&1; then
        echo -e "${White}## ${Green}apt found, ${IWhite}trying to install systemd-container..."
        # Confirm with user input
        if [ "$PROMPTS" = true ]; then
          debug 'INFO' 'Do you want to use apt to install systemd-container? (will upgrade system first) [y/n]'
          while true; do
            if [ "$COLORS" = true ]; then
              read -r -p $'\e[0;37m## \e[0;93mDo you want to use apt to install systemd-container? \e[0;97m(will upgrade system first) \e[0;92m[y/n] \e[0m' input
            else
              read -r -p '## Do you want to use apt to install systemd-container? (will upgrade system first) [y/n] ' input
            fi
            case $input in
              [Yy]) break;;
              [Nn]) echo -e "${Red}!! Aborting..."; exit 4;;
              *) echo -e "${Yellow}!! ${Red}ERROR! ${Yellow}Please enter ${Green}'y' ${Yellow}or ${Green}'n'${Yellow}"; debug 'WARNING' "ERROR, please enter 'y' or 'n'";;
            esac
          done
          debug 'INFO' 'Y or y pressed to confirm'
          debug 'BREAK'
          debug 'DEBUG' 'Running: apt update -y && apt upgrade -y && apt install systemd-container -y'
          apt update -y && apt upgrade -y && apt install systemd-container -y
        else
          debug 'DEBUG' 'Running: apt update -y && apt upgrade -y && apt install systemd-container -y'
          apt update -y && apt upgrade -y && apt install systemd-container -y
        fi
        echo -e "${White}## ${Green}systemd-container installed successfully, ${IWhite}resuming..."
        debug 'INFO' 'systemd-container installed successfully'
        $SLEEPING

      # Installation failed
      else
        echo -e "${Red}!! Error! ${Yellow}Installing systemd-nspawn (systemd-container) failed! ${Green}Please install systemd-container manually and retry script..."
        debug 'ERROR' 'Installing systemd-container failed, aborting exit 3'
        echo -e "${Red}!! Aborting..."
        exit 3
      fi

    # systemd-nspawn already installed
    else
      echo -e "${White}## ${Green}systemd-nspawn is available, ${IWhite}resuming..."
      debug 'INFO' 'systemd-nspawn is available on system'
      $SLEEPING
    fi
  fi
return 0
}



# loop img file
function do_loop() {

  # Find free loop
  if [ -z "$LOOP" ]; then
    LOOP=$(losetup -f)
    debug 'DEBUG' "LOOP=$LOOP"
  fi

  echo -e "${White}## ${IWhite}Looping img file..."
  $SLEEPING
  debug 'DEBUG' "Running: losetup -P $LOOP $IMG_FILE"
  if ! output=$(losetup -P "$LOOP" "$IMG_FILE" 2>&1); then
    echo -e "${Yellow}$output\n${Red}!! LOSETUP FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "LOSETUP FAILED:\n$output\n-------------------------------------------------------------------------------------"
    exit 3
  fi
return 0
}



# Mount img file
function do_mount() {

  partprobe "$LOOP"

  # ext4 & f2fs
  if [ "$FSTYPE" == 'ext4' ] || [ "$FSTYPE" == 'f2fs' ] || [ "$F2FS_CONVERSION" = true ]; then
    echo -e "${White}## ${IWhite}Mounting img root partition..."
    $SLEEPING
    debug 'INFO' 'Mounting root partition from loop'
    debug 'DEBUG' "Running: mount $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! ROOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "ROOT MOUNT FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

  # btrfs
  elif [ "$FSTYPE" == 'btrfs' ]; then
    declare -a fstab=( $(cat /etc/fstab | grep ' / ') )
    echo -e "${White}## ${IWhite}Mounting root (${Green}@${IWhite}) subvolume..."
    $SLEEPING
    debug 'INFO' 'Mounting root (@) subvolume from loop'
    debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! ROOT SUBVOLUME MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "ROOT SUBVOLUME MOUNT FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

    # Mount top subvolumes (except @). New top volumes will not be created during an update, if new top volumes have been created on device script will fail and exit
    debug 'INFO' 'Mounting non-root subvolumes from loop (if existing)'
    for subvol in "${LOCAL_TOP_SUBVOLUMES[@]}"; do
      # Excluding root (@) subvolume and mounting all else in fstab
      if grep -q "$subvol" /etc/fstab && [[ "$subvol" != '@' ]]; then
        declare -a fstab=( $(cat /etc/fstab | grep "$subvol") )
        echo -e "${White}## ${IWhite}Mounting subvolume: ${Green}$subvol"
        $SLEEPING
        if ! [ -d "${TMP_DIR}${fstab[1]}" ]; then
          debug 'DEBUG' "Directory for subvol $subvol did not exist, running: mkdir -p ${TMP_DIR}${fstab[1]}"
          mkdir -p ${TMP_DIR}${fstab[1]}
        fi
        debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH ${TMP_DIR}${fstab[1]}"
        if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" "${TMP_DIR}${fstab[1]}" 2>&1); then
          echo -e "${Yellow}$output\n${Red}!! SUBVOLUME MOUNT FAILED!!!"
          debug 'BREAK'
          debug 'ERROR' "SUBVOLUME MOUNT FAILED:\n$output\n-------------------------------------------------------------------------------------"
          exit 3
        fi
      fi
    done

    # Check for differences in nested subvolumes & create/remove if necessary
    if [[ $(echo $(btrfs subvolume list "$TMP_DIR" --sort=path | grep -v ' 5 ' | awk '{print $9}') ) != "${LOCAL_NESTED_SUBVOLUMES[@]}" ]]; then
      echo -e "${White}## ${IWhite}Managing nested subvolumes..."
      $SLEEPING
      debug 'INFO' 'Managing nested subvolumes'
      IMG_NESTED_SUBVOLUMES=( $(btrfs subvolume list "$TMP_DIR" --sort=path | grep -v ' 5 ' | awk '{print $9}') )
      debug 'DEBUG' "IMG_NESTED_SUBVOLUMES=$(echo ${IMG_NESTED_SUBVOLUMES[@]})"

      # Create new nested subvolume(s) if needed
      for subvol in ${LOCAL_NESTED_SUBVOLUMES[@]}; do
        if ! printf '%s\n' "${IMG_NESTED_SUBVOLUMES[@]}" | grep -qx $subvol; then
          echo -e "${White}## ${IWhite}Creating nested subvolume: ${Green}$subvol"
          $SLEEPING
          # Fix path if nested subvolume is in other location than root subvolume
          top_subvolumes="$(echo ${LOCAL_TOP_SUBVOLUMES[@]} | sed 's/ /|/g')" # convert spaces into |
          if echo "$subvol" | grep -qE "$top_subvolumes"; then
            debug 'INFO' 'Nested volume not under root, fixing path'
            for top_subvol in ${LOCAL_TOP_SUBVOLUMES[@]}; do
              if echo "$subvol" | grep -qw "$top_subvol"; then
                break
              fi
            done
            path="$(cat /etc/fstab | grep $top_subvol | awk '{print $2}' | sed 's/^\///')" # remove first slash
            subvol="$(echo $subvol | sed "s|$top_subvol|$path|g")"
          fi
          # Remove directory if existing
          if [ -d "${TMP_DIR}/${subvol}" ]; then
            debug 'DEBUG' "Directory for nested volume exists, deleting: rm -rf ${TMP_DIR}/${subvol}"
            rm -rf "${TMP_DIR}/${subvol}"
          fi
          debug 'DEBUG' "Running: btrfs subvolume create ${TMP_DIR}/$subvol"
          if ! output=$(btrfs subvolume create -p "$TMP_DIR"/"$subvol" 2>&1); then
            echo -e "${Yellow}$output\n${Red}!! CREATE NESTED SUBVOLUME FAILED!!!"
            debug 'BREAK'
            debug 'ERROR' "CREATE NESTED SUBVOLUME FAILED:\n$output\n-------------------------------------------------------------------------------------"
            exit 3
          fi
        fi
        IMG_NESTED_SUBVOLUMES=( $(btrfs subvolume list "$TMP_DIR" --sort=path | grep -v ' 5 ' | awk '{print $9}') )
        debug 'DEBUG' "IMG_NESTED_SUBVOLUMES=$(echo ${IMG_NESTED_SUBVOLUMES[@]})"
      done

      # Delete nested img subvolume(s) if needed
      for subvol in ${IMG_NESTED_SUBVOLUMES[@]}; do
        if ! printf '%s\n' "${LOCAL_NESTED_SUBVOLUMES[@]}" | grep -qx $subvol; then
          echo -e "${White}## ${IWhite}Deleting nested subvolume: ${Green}$subvol"
          $SLEEPING
          # Fix path if nested subvolume is in other location than root subvolume
          top_subvolumes="$(echo ${LOCAL_TOP_SUBVOLUMES[@]} | sed 's/ /|/g')" # convert spaces into |
          if echo "$subvol" | grep -qE "$top_subvolumes"; then
            debug 'INFO' 'Nested volume not under root, fixing path'
            for top_subvol in ${LOCAL_TOP_SUBVOLUMES[@]}; do
              if echo "$subvol" | grep -qw "$top_subvol"; then
                break
              fi
            done
            path="$(cat /etc/fstab | grep $top_subvol | awk '{print $2}' | sed 's/^\///')" # remove first slash
            subvol="$(echo $subvol | sed "s|$top_subvol|$path|g")"
          fi
          debug 'DEBUG' "Running: btrfs subvolume delete ${TMP_DIR}/$subvol"
          if ! output=$(btrfs subvolume delete "$TMP_DIR"/"$subvol" 2>&1); then
            echo -e "${Yellow}$output\n${Red}!! DELETE NESTED SUBVOLUME FAILED!!!"
            debug 'BREAK'
            debug 'ERROR' "DELETE NESTED SUBVOLUME FAILED:\n$output\n-------------------------------------------------------------------------------------"
            exit 3
          fi
        fi
      done
      IMG_NESTED_SUBVOLUMES=( $(btrfs subvolume list "$TMP_DIR" --sort=path | grep -v ' 5 ' | awk '{print $9}') )
      debug 'DEBUG' "IMG_NESTED_SUBVOLUMES=$(echo ${IMG_NESTED_SUBVOLUMES[@]})"
    fi
  fi

  # Mount boot partition if exists
  if [ -n "$BOOT_PATH" ]; then
    echo -e "${White}## ${IWhite}Mounting img boot partition..."
    $SLEEPING
    debug 'INFO' 'Mounting boot inside root'
    if ! [ -d ${TMP_DIR}${BOOT_PATH} ]; then
      debug 'INFO' 'Boot directory did not exist on img'
      debug 'DEBUG' "Running: mkdir -p ${TMP_DIR}${BOOT_PATH}"
      mkdir -p ${TMP_DIR}${BOOT_PATH}
    fi
    debug 'DEBUG' "Running: mount $IMG_DEV_BOOT_PATH ${TMP_DIR}${BOOT_PATH}"
    if ! output=$(mount "$IMG_DEV_BOOT_PATH" "${TMP_DIR}${BOOT_PATH}" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! BOOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "BOOT MOUNT FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi
  fi
return 0
}



# Check filesystem
function do_e2fsck() {

  if [ -n "$BOOT_PATH" ] && [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}${BOOT_PATH} " /proc/mounts; then
    debug 'INFO' 'Unmounting boot partition'
    debug 'DEBUG' "Running: umount ${TMP_DIR}${BOOT_PATH}"
    umount "${TMP_DIR}${BOOT_PATH}"
  fi

  if [ -n "$TMP_DIR" ] && grep -qs "$TMP_DIR " /proc/mounts; then
    debug 'INFO' 'Unmounting root partition'
    debug 'DEBUG' "Running: umount $TMP_DIR"
    umount "$TMP_DIR"
  fi

  # Final check of filesystem
  if [ "$*" == 'final' ]; then
    echo -e "${White}## ${IWhite}Finalizing filesystem..."
    $SLEEPING

    output=$(e2fsck -p -f -v "$IMG_DEV_ROOT_PATH" 2>&1)
    echo "$output"
    debug 'BREAK'
    debug 'DEBUG' "Running: e2fsck -p -f -v $IMG_DEV_ROOT_PATH\n$output\n-------------------------------------------------------------------------------------"
    $SLEEPING

    # Remounting if autoexpansion is requested
    if [[ ( "$AUTOEXPAND" = true  && "$OS" != 'unknown' ) || ( "$AUTOEXPAND" = false && "$OS" == 'ubuntu' ) ]]; then
      echo -e "${White}## ${IWhite}Remounting for autoexpansion..."
      debug 'INFO' 'Remounting for autoexpansion function'
      debug 'INFO' 'Running function: do_mount'
      $SLEEPING
      do_mount
    fi

  # Normal check
  else
    echo -e "${White}## ${IWhite}Checking img filesystem..."
    $SLEEPING

    output=$(e2fsck -p -f "$IMG_DEV_ROOT_PATH" 2>&1)
    echo "$output"
    debug 'DEBUG' "Running: e2fsck -p -f $IMG_DEV_ROOT_PATH\n$output\n-------------------------------------------------------------------------------------"
    $SLEEPING
  fi
return 0
}



# Resize image
function do_resize() {

  # Reading offset for img root partition
  debug 'INFO' 'Using fdisk to find img root partition offset'
  debug 'DEBUG' "Running: fdisk -lo start $IMG_FILE | tail -1"
  IMG_ROOT_START=$(fdisk -lo start "$IMG_FILE" | tail -1 | awk '{print $1}') # blocks, 521B block size
  debug 'DEBUG' "IMG_ROOT_START=$IMG_ROOT_START blocks"
  IMG_ROOT_START=$(( IMG_ROOT_START * 512 )) # bytes
  debug 'DEBUG' "IMG_ROOT_START=${IMG_ROOT_START}B"

  # Converting TOTAL > TOTALK (bytes > kibibytes)
  debug 'INFO' 'Converting TOTAL > TOTALK (bytes > kibibytes)'
  TOTALK=$(( TOTAL / 1024 )) # kibibytes
  debug 'DEBUG' "TOTAL=${TOTAL}B | TOTALK=${TOTALK}KiB"

  # Gather information
  debug 'INFO' 'Using parted to fetch root partition number'
  debug 'DEBUG' "Running: parted -sm "$LOOP" print | tail -1 | cut -d : -f 1"
  IMG_ROOT_PARTN=$(parted -sm "$LOOP" print | tail -1 | cut -d : -f 1)
  debug 'DEBUG' "IMG_ROOT_PARTN=$IMG_ROOT_PARTN"

  # Check img filesystem
  if [ $FSTYPE == 'ext4' ]; then
    debug 'INFO' 'Running function: do_e2fsck'
    do_e2fsck
  fi


  # Expanding
  if [ "$*" = 'expand' ]; then

    echo -e "${White}## ${Yellow}Expanding img filesystem..."
    $SLEEPING

    # Removing loop for truncate to take effect
    echo -e "${White}## ${IWhite}Removing loop..."
    $SLEEPING
    debug 'INFO' 'Removing loop for truncate to take effect'
    debug 'DEBUG' "Running: losetup -d $LOOP"
    losetup -d "$LOOP"

    echo -e "${White}## ${Yellow}Expanding image file..."
    $SLEEPING
    debug 'INFO' "Using truncate to resize img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
    debug 'DEBUG' "Running: truncate --size=$TRUNCATE_TOTAL $IMG_FILE"
    if ! output=$(truncate --size="$TRUNCATE_TOTAL" "$IMG_FILE" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! TRUNCATE FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "TRUNCATE FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

    # Loop img file
    debug 'INFO' 'Re-looping img file to fetch new img size'
    debug 'INFO' 'Running function: do_loop'
    do_loop

    echo -e "${White}## ${IWhite}Removing partition..."
    $SLEEPING
    #debug 'INFO' 'Using sfdisk to remove root partition'
    debug 'INFO' 'Using parted to remove root partition'
    #debug 'DEBUG' "Running: sfdisk --delete -f $LOOP $IMG_ROOT_PARTN"
    debug 'DEBUG' "Running: parted -s $LOOP rm $IMG_ROOT_PARTN"
    #debug 'DEBUG' "Running: printf 'Ignore\\\n'$IMG_ROOT_PARTN | parted $LOOP rm $IMG_ROOT_PARTN ---pretend-input-tty"

    #if ! output=$(sfdisk --delete -f "$LOOP" "$IMG_ROOT_PARTN" 2>&1); then # might fail if img size is very big
    if ! output=$(parted -s "$LOOP" rm "$IMG_ROOT_PARTN" 2>&1); then # for some reason this line works here but not when creating img
    #if ! output=$(printf 'Ignore\n'$IMG_ROOT_PARTN | parted $LOOP rm $IMG_ROOT_PARTN ---pretend-input-tty 2>&1); then # raspberry pi os does not like this method, keep for memory
      #echo -e "${Yellow}$output\n${Red}!! SFDISK FAILED!!!"
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!"
      debug 'BREAK'
      #debug 'ERROR' "SFDISK FAILED:\n$output\n-------------------------------------------------------------------------------------"
      debug 'ERROR' "PARTED FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

    echo -e "${White}## ${IWhite}Recreating partition..."
    $SLEEPING
    debug 'INFO' 'Using parted to recreate root partition'
    debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary ext4 $IMG_ROOT_START 100%"
    if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary ext4 "$IMG_ROOT_START" 100% 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

    echo -e "${White}## ${Yellow}Expanding filesystem..."
    $SLEEPING
    debug 'INFO' 'Using resize2fs to expand filesystem'
    debug 'BREAK'
    debug 'DEBUG' "Running: resize2fs -p -f $IMG_DEV_ROOT_PATH"
    if ! output=$(resize2fs -p -f "$IMG_DEV_ROOT_PATH" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! RESIZE2FS FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "RESIZE2FS FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi
    debug 'DEBUG' "$output\n-------------------------------------------------------------------------------------"

    # Check img filesystem
    if [ $FSTYPE == 'ext4' ]; then
      debug 'INFO' 'Running function: do_e2fsck'
      do_e2fsck
    fi


  # Shrinking
  elif [ "$*" = 'shrink' ]; then

    echo -e "${White}## ${Yellow}Shrinking filesystem..."
    $SLEEPING
    debug 'INFO' 'Using resize2fs to shrink filesystem'
    debug 'BREAK'
    debug 'DEBUG' "Running: resize2fs -p -f $IMG_DEV_ROOT_PATH ${TOTALK}K"
    if ! output=$(resize2fs -p -f "$IMG_DEV_ROOT_PATH" "$TOTALK"K 2>&1 | tee "$TTY_AVAILABILITY"); then
      echo -e "${Red}$output\n${Red}!! RESIZE2FS FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "RESIZE2FS FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi
    debug 'DEBUG' "$output\n-------------------------------------------------------------------------------------"

    echo -e "${White}## ${Yellow}Shrinking partition..."
    $SLEEPING
    debug 'INFO' 'Using parted to shrink partition'
    debug 'BREAK'
    #debug 'DEBUG' "Running: parted -s -a none $LOOP unit B resizepart $IMG_ROOT_PARTN $TRUNCATE_TOTAL"
    debug 'DEBUG' "Running: printf 'Yes\\\n' | parted -a none $LOOP unit B resizepart $IMG_ROOT_PARTN $TRUNCATE_TOTAL ---pretend-input-tty"

    #if ! output=$(parted -s -a none "$LOOP" unit B resizepart "$IMG_ROOT_PARTN" "$TRUNCATE_TOTAL" 2>&1); then # tested may 2024 and does not work, still asking for user confirmation
    if ! output=$(printf 'Yes\n' | parted -a none "$LOOP" unit B resizepart "$IMG_ROOT_PARTN" "$TRUNCATE_TOTAL" ---pretend-input-tty 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi
    debug 'DEBUG' "$output\n-------------------------------------------------------------------------------------"

    echo -e "${White}## ${Yellow}Shrinking img file..."
    $SLEEPING
    debug 'INFO' "Using truncate to shrink img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
    debug 'DEBUG' "Running: truncate --size=$TRUNCATE_TOTAL $IMG_FILE"
    if ! output=$(truncate --size="$TRUNCATE_TOTAL" "$IMG_FILE" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! TRUNCATE FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "TRUNCATE FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi
  fi
return 0
}



# rsync to img file
function do_rsync() {

  echo -e "${White}## ${IWhite}Backing up files..."
  $SLEEPING
  if [ "$TTY_AVAILABILITY" == '/dev/null' ] || [ "$RSYNC_TTY" = false ]; then
    echo -e "${White}## ${Yellow}This might take some time, please stand by..."
  fi
  debug 'DEBUG' "Backing up to ${IMG_PATH}${IMG_FILE}"

  # Run rsync
  eval "$RSYNC_LINE"

  # Get the exit status of rsync from PIPESTATUS
  if [ "${PIPESTATUS[0]}" -ne 0 ] && [ "${PIPESTATUS[0]}" -ne 23 ]; then # code 23 = rsync warning: some files vanished before they could be transferred (code 24) at main.c
    output=$(tail -16 "$tmp_file")
    echo -e "${Yellow}$output\n${Red}!! RSYNC FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "RSYNC FAILED:\nPIPESTATUS=${PIPESTATUS[0]}\n$output\n-------------------------------------------------------------------------------------"
    exit 5
  elif [ "${PIPESTATUS[0]}" -eq 23 ]; then
    echo -e "${White}## ${Yellow}Warning, rsync code 23, some files vanished before they could be transferred (code 24) at main.c"
    echo -e "${White}## ${Yellow}This does NOT mean the backup failed"
    $SLEEPING
    debug 'WARNING' 'rsync code 23, some files vanished before they could be transferred (code 24) at main.c'
  fi

  echo -e "${White}## ${Green}Rsync done..."
  echo -e "${White}## ${IWhite}Please stand by..."
  output=$(tail -16 "$tmp_file")
  debug 'BREAK'
  debug 'DEBUG' "Rsync report:\n$output\n-------------------------------------------------------------------------------------"
  debug 'INFO' 'Rsync done'
  sleep 4
return 0
}



# Edit config files for conversion
function do_conversion() {

  # Create partition
  if [ "$*" == 'create_partition' ]; then

    # f2fs
    if [ "$F2FS_CONVERSION" = true ]; then
      debug 'INFO' '--f2fs selected by user, creating f2fs partition on img file'
      debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary f2fs $LOCAL_ROOT_START 100%"
      if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary f2fs "$LOCAL_ROOT_START" 100% 2>&1); then
        echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!"
        debug 'BREAK'
        debug 'ERROR' "PARTED FAILED:\n$output\n-------------------------------------------------------------------------------------"
        exit 3
      fi
    fi

  # Format filesystem
  elif [ "$*" == 'format_filesystem' ]; then

    # f2fs
    if [ "$F2FS_CONVERSION" = true ]; then
      debug 'INFO' "Using mkfs.f2fs to format root filesystem"
      if ! output=$(mkfs.f2fs -f -U "$UUID" -l "$LABEL" "$IMG_DEV_ROOT_PATH" 2>&1 | tee "$TTY_AVAILABILITY" ); then
        echo -e "${Yellow}$output\n${Red}!! MKFS.F2FS FAILED!!!"
        debug 'BREAK'
        debug 'ERROR' "MKFS.F2FS FAILED:\n$output\n-------------------------------------------------------------------------------------"
        exit 3
      fi
      debug 'BREAK'
      debug 'DEBUG' "Running: mkfs.f2fs -f -U $UUID -l $LABEL $IMG_DEV_ROOT_PATH\n$output\n-------------------------------------------------------------------------------------"
      $SLEEPING

      debug 'INFO' 'Running function: do_mount'
      do_mount
    fi

  # Edit config files
  elif [ "$*" == 'edit_configs' ]; then

    # f2fs
    if [ "$F2FS_CONVERSION" = true ]; then
      echo -e "${White}## ${IWhite}Editing img configurations for f2fs..."
      $SLEEPING
      echo -e "${White}## ${IWhite}Backups will be created: ${Green}/etc/fstab.shrink-backup.bak ${IWhite}& ${Green}${BOOT_PATH}/cmdline.txt.shrink-backup.bak"
      debug 'INFO' 'Configuring fstab and cmdline.txt on img file for f2fs'
      $SLEEPING

      # Create backups
      debug 'INFO' 'Backing up fstab & cmdline.txt into fstab.shrink-backup.bak & cmdline.shrink-backup.bak on img'
      cp ${TMP_DIR}/etc/fstab ${TMP_DIR}/etc/fstab.shrink-backup.bak
      cp ${TMP_DIR}${BOOT_PATH}/cmdline.txt ${TMP_DIR}${BOOT_PATH}/cmdline.txt.shrink-backup.bak

      # fstab
      debug 'DEBUG' "Old root line in fstab=$(cat ${TMP_DIR}/etc/fstab | grep ' / ')"
      fstab_options=$(cat ${TMP_DIR}/etc/fstab | grep ' / ' | awk '{print $4}')
      debug 'DEBUG' "Running: sed -i -e \"/${LOCAL_ROOT_PARTUUID}/s/ext4/f2fs/\" -e \"/${LOCAL_ROOT_PARTUUID}/s/${fstab_options}/${fstab_options},discard/\" ${TMP_DIR}/etc/fstab"
      sed -i -e "/${LOCAL_ROOT_PARTUUID}/s/ext4/f2fs/" -e "/$LOCAL_ROOT_PARTUUID/s/${fstab_options}/${fstab_options},discard/" ${TMP_DIR}/etc/fstab
      debug 'DEBUG' "New root line in fstab=$(cat ${TMP_DIR}/etc/fstab | grep ' / ')"

      # cmdline.txt
      debug 'INFO' "Old line in cmdline.txt: $(cat ${TMP_DIR}${BOOT_PATH}/cmdline.txt | grep 'console')"
      debug 'DEBUG' "Running: sed -i 's/rootfstype=ext4/rootfstype=f2fs/' ${TMP_DIR}${BOOT_PATH}/cmdline.txt"
      sed -i 's/rootfstype=ext4/rootfstype=f2fs/' "${TMP_DIR}${BOOT_PATH}"/cmdline.txt
      debug 'DEBUG' "New line in cmdline.txt: $(cat ${TMP_DIR}${BOOT_PATH}/cmdline.txt | grep 'console')"
    fi
  fi
return 0
}



# Create a backup img file
function make_img() {

  debug 'INFO' 'Running function: dev_variables'
  # btrfs_variables is run within dev_variables
  dev_variables
  debug 'INFO' 'Running function: rsync_line'
  rsync_line

  # Display information
  echo -e "${Purple}$BREAK"
  if [ "$PROMPTS" = false ]; then
    debug 'INFO' '-y selected by user. prompts are disabled'
    echo -e "# ${Yellow}DISABLE PROMPTS SELECTED (${Green}-y${Yellow}), NO WARNINGS ABOUT DELETION!!! ${Purple}$(printf "%+$(( COLS - 63 ))s" '#')"
  fi
  #echo -e "# ${IWhite}A backup will be created at ${Green}$IMG_FILE $(while [ $x -lt $(( COLS - 31 - $(echo ${IMG_FILE} | wc -m ) )) ]; do echo -n ' '; let x=$x+1; done; echo)${Purple}#"
  echo -e "# ${IWhite}A backup will be created at: ${Purple}$(printf "%+$(( COLS - 31 ))s" '#')"
  echo -e "# ${Green}$IMG_FILE ${Purple}$(printf "%+$(( COLS - 2 - $(echo ${IMG_FILE} | wc -m ) ))s" '#')"
  echo -e "# ${Green}$FSTYPE ${IWhite}filesystem detected on root ${Purple}$(printf "%+$(( COLS - 30 - $(echo ${FSTYPE} | wc -m ) ))s" '#')"
  if [ "$RSYNC_DELETE" != '--delete' ]; then
    echo -e "# ${Green}--fix ${IWhite}option selected, ${Green}rsync using --fsync option${Purple}$(printf "%+$(( COLS - 51 ))s" '#')"
  fi
  if [ "$FSTYPE" == 'btrfs' ]; then
    echo -e "# ${Green}${#LOCAL_TOP_SUBVOLUMES[@]} ${IWhite}btrfs top volumes will be included ${Purple}$(printf "%+$(( COLS - 37 - $(echo ${#LOCAL_TOP_SUBVOLUMES[@]} | wc -m ) ))s" '#')"
    echo -e "${Purple}# ${IWhite}btrfs top volumes: ${Green}${LOCAL_TOP_SUBVOLUMES[@]} ${Purple}$(printf "%+$(( COLS - 21 - $(echo ${LOCAL_TOP_SUBVOLUMES[@]} | wc -m ) ))s" '#')"
    echo -e "# ${Green}${#LOCAL_NESTED_SUBVOLUMES[@]} ${IWhite}btrfs nested volumes will be included ${Purple}$(printf "%+$(( COLS - 40 - $(echo ${#LOCAL_NESTED_SUBVOLUMES[@]} | wc -m ) ))s" '#')"
    echo -e "${Purple}# ${IWhite}btrfs nested volumes: ${Green}${LOCAL_NESTED_SUBVOLUMES[@]} ${Purple}$(printf "%+$(( COLS - 24 - $(echo ${LOCAL_NESTED_SUBVOLUMES[@]} | wc -m ) ))s" '#')"
  elif [ "$FSTYPE" == 'f2fs' ]; then
    echo -e "# ${Yellow}Autoexpand filesystem at boot not available for ${Green}f2fs ${Purple}$(printf "%+$(( COLS - 54 ))s" '#')"
  elif [ "$F2FS_CONVERSION" = true ]; then
    echo -e "# ${Yellow}Converting filesystem into ${Green}f2fs ${Yellow}on img file ${Purple}$(printf "%+$(( COLS - 46 ))s" '#')"
    echo -e "# ${Yellow}Autoexpand filesystem at boot not available for ${Green}f2fs ${Purple}$(printf "%+$(( COLS - 55 ))s" '#')"
  fi
  if [ "$RSYNC_CUSTOM" = true ]; then
    echo -e "# ${IWhite}Custom rsync line: ${Purple}$(printf "%+$(( COLS - 21 ))s" '#')"
    echo -e "  ${Green}$RSYNC_CUSTOM_LINE"
  fi
  echo -e "${Purple}# $(printf %$(( COLS - 4 ))s | tr ' ' '-') #"
  echo -e "# ${IWhite}Write to logfile:              ${Green}$DEBUG ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${DEBUG} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Zoom speed requested:          ${Green}$ZOOM ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${ZOOM} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}rsync tty output:              ${Green}$RSYNC_TTY ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${RSYNC_TTY} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Autocalculate img root size:   ${Green}$AUTORESIZE_RUN ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${AUTORESIZE_RUN} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Autoexpand filesystem at boot: ${Green}$AUTOEXPAND ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${AUTOEXPAND} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Use exclude.txt:               ${Green}$EXCLUDE_FILE ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${EXCLUDE_FILE} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Boot partition:                ${Green}$BOOT_PARTITION ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${BOOT_PARTITION} | wc -m ) ))s" '#')"
  print_temp="$(( LOCAL_BOOTSECTOR / 1024 / 1024 ))"
  echo -e "# ${IWhite}Bootsector size:               ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
  print_temp="$(( $(df / -k --sync --output=used | tail -1) / 1024 ))"
  echo -e "# ${IWhite}Estimated root usage:          ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
  if [ "$AUTORESIZE_RUN" = true ]; then
    print_temp="$(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))"
    echo -e "# ${IWhite}Auto calculated root size:     ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
    print_temp="$(( TRUNCATE_TOTAL / 1024 / 1024 ))"
    echo -e "# ${IWhite}Total img size:                ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
  else
    print_temp="$(( TRUNCATE_TOTAL / 1024 / 1024 ))"
    print_temp2="$(( ADDED_SPACE / 1024 / 1024 ))"
    echo -e "# ${IWhite}Total img size:                ${Green}${print_temp}MiB ${IWhite}with ${Green}${print_temp2}MiB [extra space] ${IWhite}included ${Purple}$(printf "%+$(( COLS - 67 - $(echo ${print_temp} | wc -m ) - $(echo ${print_temp2} | wc -m ) ))s" '#')"
    if [ "$AUTORESIZE_WARNING" = true ]; then
      echo -e "${Yellow}# $(printf %$(( COLS - 4 ))s | tr ' ' '-') #"
      echo -e "! WARNING!!! Manually added space is smaller than calculated recommended minimum $(printf "%+$(( COLS - 81 ))s" '!')"
      echo -e "! This does NOT mean the backup WILL fail, but CAN fail due to lack of space $(printf "%+$(( COLS - 77 ))s" '!')"
      echo -e "! Consider using the -a option or manually adding more space $(printf "%+$(( COLS - 61 ))s" '!')"
      print_temp="$(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))"
      echo -e "! ${IWhite}Calculated recommended minimum: ${Green}${print_temp}MiB ${Yellow}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '!')"
      print_temp="$(( TOTAL / 1024 / 1024 ))"
      echo -e "! ${IWhite}Requested root size:            ${Yellow}${print_temp}MiB $(printf "%+$(( COLS - 37 - $(echo ${print_temp} | wc -m ) ))s" '!')"
    fi
  fi
  if [ "$F2FS_CONVERSION" = true ]; then
    echo -e "${Yellow}# $(printf %$(( COLS - 4 ))s | tr ' ' '-') #"
    echo -e "! WARNING!!! --f2fs option selected. f2fs filesystem will be created on img file $(printf "%+$(( COLS - 81 ))s" '!')"
    echo -e "! This option is only for CONVERTING existing filesystem into f2fs on img file $(printf "%+$(( COLS - 79 ))s" '!')"
    echo -e "! This option is NOT needed for normal backups from f2fs on root $(printf "%+$(( COLS - 65 ))s" '!')"
    echo -e "! ${IWhite}Only tested on Raspberry pi OS ${Yellow}$(printf "%+$(( COLS - 33 ))s" '!')"
  fi

  # Disabled prompts
  if [ "$PROMPTS" = false ] && [ "$ZOOM" = false ]; then
    echo -e "${Red}!! PRESS CTRL+C WITHIN 5s TO CANCEL !! $(printf "%+$(( COLS - 39 ))s" '#')"
    echo -e "${Red}${BREAK}"
    sleep 6
    debug 'INFO' '6 seconds passed, user did not stop operation'
    debug 'BREAK'

  # Confirm with user input
  elif [ "$PROMPTS" = true ]; then
    echo -e "${Purple}${BREAK}${IWhite}"
    debug 'INFO' 'Do you want to continue? [y/n]'
    while true; do
      if [ "$COLORS" = true ]; then
        read -r -p $'\e[0;37m## \e[0;97mDo you want to continue? \e[0;92m[y/n] \e[0m' input
      else
        read -r -p '## Do you want to continue? [y/n] ' input
      fi
      case $input in
        [Yy]) debug 'INFO' 'Y or y pressed to confirm'; debug 'BREAK'; break;;
        [Nn]) echo -e "${Red}!! Aborting..."; exit 4;;
        *) echo -e "${Yellow}!! ${Red}ERROR! ${Yellow}Please enter ${Green}'y' ${Yellow}or ${Green}'n'${Yellow}"; debug 'WARNING' "ERROR, please enter 'y' or 'n'";;
      esac
    done

    if test -f "$IMG_FILE"; then
      debug 'WARNING' "$IMG_FILE ALREADY EXISTS!"
      echo -e "${Yellow}!! ${Red}WARNING!!! WARNING!!! WARNING!!!"
      echo -e "${Yellow}!! ${Green}$IMG_FILE"
      echo -e "${Yellow}!! FILE ALREADY EXISTS!!!"
      debug 'WARNING' 'Do you want to overwrite? [y/n]'
      while true; do
        if [ "$COLORS" = true ]; then
          read -r -p $'\e[0;37m## \e[0;97mDo you want to overwrite? \e[0;92m[y/n] \e[0m' input
        else
          read -r -p '## Do you want to overwrite? [y/n] ' input
        fi
        case $input in
          [Yy]) debug 'WARNING' 'Overwrite confirmed by user'; break;;
          [Nn]) echo -e "${Red}!! Aborting..."; exit 4;;
          *) echo -e "${Yellow}!! ${Red}ERROR! ${Yellow}Please enter ${Green}'y' ${Yellow}or ${Green}'n'${Yellow}"; debug 'WARNING' "ERROR, please enter 'y' or 'n'";;
        esac
      done
    fi
  else
    echo -e "${Purple}${BREAK}${IWhite}"
  fi

  # Delete existing file if user validation above passed
  if [ -f "$IMG_FILE" ]; then
    debug 'WARNING' "Removing: $IMG_FILE"
    echo -e "${Yellow}!! Removing old img file..."
    rm "$IMG_FILE"
    $SLEEPING
  fi

  # Create and dd bootsector
  echo -e "${White}## ${IWhite}Creating bootsector..."
  if [ "$TTY_AVAILABILITY" == '/dev/null' ]; then
    echo '## This might take some time, please stand by...'
  fi
  $SLEEPING
  debug 'INFO' 'Using dd to create bootsector'
  debug 'DEBUG' "Running: dd bs=512 count=$LOCAL_DDBOOTSECTOR if=$LOCAL_DEV_PATH of=$IMG_FILE conv=noerror,sync status=progress"
  if ! output=$(dd bs=512 count=$LOCAL_DDBOOTSECTOR if="$LOCAL_DEV_PATH" of="$IMG_FILE" conv=noerror,fsync status=progress 2>&1 | tee "$TTY_AVAILABILITY") && sync; then
    echo -e "${Yellow}$output\n${Red}!! DD TO LOCAL_BOOTSECTOR FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "DD TO LOCAL_BOOTSECTOR FAILED:\n$output\n-------------------------------------------------------------------------------------"
    exit 3
  fi
  output=$(echo "$output" | tail -3 )
  debug 'BREAK'
  debug 'DEBUG' "dd completed:\n$output\n-------------------------------------------------------------------------------------"
  $SLEEPING

  # Truncate file to correct size
  echo -e "${White}## ${IWhite}Resizing img file..."
  $SLEEPING
  debug 'INFO' "Using truncate to resize img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
  debug 'DEBUG' "Running: truncate --size=$TRUNCATE_TOTAL $IMG_FILE"
  if ! output=$(truncate --size="$TRUNCATE_TOTAL" "$IMG_FILE" 2>&1); then
    echo -e "${Yellow}$output\n${Red}!! TRUNCATE FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "TRUNCATE FAILED:\n$output\n-------------------------------------------------------------------------------------"
    exit 3
  fi
  $SLEEPING

  # Loop img file
  debug 'INFO' 'Running function: do_loop'
  do_loop

  # Remove partition
  echo -e "${White}## ${IWhite}Removing root partition..."
  $SLEEPING

  # GPT
  if [ $PARTITION_TABLE == 'gpt' ]; then
    debug 'INFO' 'Using sgdisk to remove root partition'
    debug 'DEBUG' "Running: sgdisk $LOOP -d $LOCAL_ROOT_PARTN"
    if ! output=$(sgdisk "$LOOP" -d "$LOCAL_ROOT_PARTN" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! SGDISK FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "SGDISK FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

  # MBR
  else
    # Keep all of this for memory, things needed to get this to work seems to change back and forth over time
    debug 'INFO' 'Using sfdisk to remove root partition'
    #debug 'INFO' 'Using parted to remove root partition'
    debug 'DEBUG' "Running: sfdisk --delete -f $LOOP $LOCAL_ROOT_PARTN"
    #debug 'DEBUG' "Running: parted -s $LOOP rm $LOCAL_ROOT_PARTN"
    #debug 'DEBUG' "Running: printf 'Ignore\\\n'$LOCAL_ROOT_PARTN | parted $LOOP rm $LOCAL_ROOT_PARTN ---pretend-input-tty"

    if ! output=$(sfdisk --delete -f "$LOOP" "$LOCAL_ROOT_PARTN" 2>&1); then # might fail if img size is very big
    #if ! output=$(parted -s "$LOOP" rm "$LOCAL_ROOT_PARTN" 2>&1); then # retry this after -f got removed, before = does not work, still asking for user confirmation even though --script and -f (automatically answer "fix" to exceptions in script mode) is used. faults with: "Error: Can't have a partition outside the disk!". for some reason this line works in the resizing function
    #if ! output=$(printf 'Ignore\n'$LOCAL_ROOT_PARTN | parted $LOOP rm $LOCAL_ROOT_PARTN ---pretend-input-tty 2>&1); then # raspberry pi os does not like this method, keep for memory
      echo -e "${Yellow}$output\n${Red}!! SFDISK FAILED!!!"
      #echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "SFDISK FAILED:\n$output\n-------------------------------------------------------------------------------------"
      #debug 'ERROR' "PARTED FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi
  fi
  $SLEEPING

  # Recreate partition
  echo -e "${White}## ${IWhite}Recreating root partition..."
  $SLEEPING
  debug 'INFO' 'Using parted to recreate root partition'

  # Converting
  if [ "$F2FS_CONVERSION" = true ]; then
    debug 'INFO' "Running function: do_conversion 'create_partition'"
    do_conversion 'create_partition'

  # ext4 or f2fs on root
  elif [ "$FSTYPE" == 'ext4' ] || [ "$FSTYPE" == 'f2fs' ]; then
    debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary $LOCAL_ROOT_START 100%"
    # Figure out why I am not using below line for ALL filesystems including converting
    #if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary "$FSTYPE" "$LOCAL_ROOT_START" 100% 2>&1); then
    if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary "$LOCAL_ROOT_START" 100% 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

  # btrfs on root
  elif [ "$FSTYPE" == 'btrfs' ]; then
    debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary btrfs $LOCAL_ROOT_START 100%"
    if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary btrfs "$LOCAL_ROOT_START" 100% 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi
  fi
  $SLEEPING

  # Get img variables
  debug 'INFO' 'Running function: img_variables'
  img_variables

  # Format filesystem
  echo -e "${White}## ${IWhite}Formatting filesystem..."
  debug 'INFO' 'Formatting filesystem'
  $SLEEPING
  LABEL=$(lsblk -no label "$LOCAL_DEV_ROOT_PATH")
  UUID=$(lsblk -no uuid "$LOCAL_DEV_ROOT_PATH")
  debug 'DEBUG' "LABEL=$LABEL | UUID=$UUID"

  # Converting
  if [ "$F2FS_CONVERSION" = true ]; then
    debug 'INFO' "Running function: do_conversion 'format_filesystem'"
    do_conversion 'format_filesystem'

  # f2fs
  elif [ "$FSTYPE" == 'f2fs' ]; then
    debug 'INFO' "Using mkfs.f2fs to format root filesystem"
    if ! output=$(mkfs.f2fs -f -U "$UUID" -l "$LABEL" "$IMG_DEV_ROOT_PATH" 2>&1 | tee "$TTY_AVAILABILITY" ); then
      echo -e "${Yellow}$output\n${Red}!! MKFS.F2FS FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "MKFS.F2FS FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi
    debug 'BREAK'
    debug 'DEBUG' "Running: mkfs.f2fs -f -U $UUID -l $LABEL $IMG_DEV_ROOT_PATH\n$output\n-------------------------------------------------------------------------------------"
    $SLEEPING

    debug 'INFO' 'Running function: do_mount'
    do_mount

  # ext4
  elif [ "$FSTYPE" == 'ext4' ]; then
    debug 'INFO' "Using mkfs.ext4 to format root filesystem"
    if ! output=$(mkfs.ext4 -U "$UUID" -L "$LABEL" "$IMG_DEV_ROOT_PATH" 2>&1 | tee "$TTY_AVAILABILITY" ); then
      echo -e "${Yellow}$output\n${Red}!! MKFS.EXT4 FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "MKFS.EXT4 FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi
    debug 'BREAK'
    debug 'DEBUG' "Running: mkfs.$FSTYPE -U $UUID -L $LABEL $IMG_DEV_ROOT_PATH\n$output\n-------------------------------------------------------------------------------------"
    $SLEEPING

    debug 'INFO' 'Running function: do_e2fsck'
    do_e2fsck

    debug 'INFO' 'Running function: do_mount'
    do_mount

  # btrfs
  elif [ "$FSTYPE" == 'btrfs' ]; then
    debug 'INFO' 'Using mkfs.btrfs to format root filesystem'
    partprobe "$LOOP"
    # btrfs does work with having the same UUID on 2 filesystems at the same time but the PARTUUID is the same anyway since it's transferred with dd
    if ! output=$(mkfs.btrfs -f -m single -L "$LABEL" -v "$IMG_DEV_ROOT_PATH" 2>&1 | tee "$TTY_AVAILABILITY" ); then
      echo -e "${Yellow}$output\n${Red}!! MKFS.BTRFS FAILED!!!"
      $SLEEPING
      debug 'BREAK'
      debug 'ERROR' "MKFS.BTRFS FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi
    debug 'BREAK'
    debug 'DEBUG' "Running: mkfs.btrfs -f -m single -L $LABEL -v $IMG_DEV_ROOT_PATH\n$output\n-------------------------------------------------------------------------------------"

    # Mount btrfs filesystem and create volumes
    echo -e "${White}## ${IWhite}Creating btrfs subvolumes..."
    $SLEEPING
    debug 'INFO' 'Mounting btrfs filesystem and creating btrfs subvolumes'
    debug 'DEBUG' "Running: mount -o noatime,compress=zstd $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount -o noatime,compress=zstd "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! BTRFS FILESYSTEM MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "BTRFS FILESYSTEM MOUNT FAILED:\n$output\n-------------------------------------------------------------------------------------"
      exit 3
    fi

    # Create top level subvolumes
    for subvol in "${LOCAL_TOP_SUBVOLUMES[@]}"; do
      echo -e "${White}## ${IWhite}Creating subvolume: ${Green}$subvol"
      $SLEEPING
      debug 'DEBUG' "Running: btrfs subvolume create ${TMP_DIR}/${subvol}"
      if ! output=$(btrfs subvolume create "$TMP_DIR"/"$subvol" 2>&1); then
        echo -e "${Yellow}$output\n${Red}!! CREATE SUBVOLUME FAILED!!!"
        debug 'BREAK'
        debug 'ERROR' "CREATE SUBVOLUME FAILED:\n$output\n-------------------------------------------------------------------------------------"
        exit 3
      fi
    done

    # Nested volumes are created within do_mount function
    debug 'INFO' 'Unmounting btrfs filesystem & running function: do_mount'
    umount "$TMP_DIR"
    do_mount
  fi

  # Copy files
  debug 'INFO' 'Backing up files'
  debug 'INFO' 'Running function: do_rsync'
  do_rsync

  # Edit config files for conversion
  if [ "$F2FS_CONVERSION" = true ]; then
    debug 'INFO' "Running function: do_conversion 'edit_configs'"
    do_conversion 'edit_configs'
  fi

  # Final check of created img file
  if [ "$FSTYPE" == 'ext4' ] && [ "$F2FS_CONVERSION" = false ]; then
    debug 'INFO' "Running function: do_e2fsck 'final'"
    do_e2fsck 'final'
  fi
return 0
}



# Update existing backup img file
function update_img() {

  # Make sure img file exists
  if ! [ -f "$IMG_FILE" ]; then
    echo -e "${Red}!! ERROR! ${Green}$IMG_FILE ${Yellow}does not exist!"
    debug 'ERROR' "$IMG_FILE does not exist, exit 3"
    exit 3
  fi

  debug 'INFO' 'Running function: dev_variables'
  # btrfs_variables is run within dev_variables
  dev_variables
  debug 'INFO' 'Running function: rsync_line'
  rsync_line
  debug 'INFO' 'Running function: do_loop'
  do_loop
  debug 'INFO' 'Running function: img_variables'
  img_variables

  # Check if resizing should be performed
  if [ "$AUTORESIZE_RUN" = true ]; then
    debug 'DEBUG' "Running: fdisk --bytes -lo device,size "$LOOP" | grep "$IMG_DEV_ROOT_PATH" | awk '{print \$2}'"
    IMG_ROOT_SIZE=$(fdisk --bytes -lo device,size "$LOOP" | grep "$IMG_DEV_ROOT_PATH" | awk '{print $2}' )
    diff=$(( (LOCAL_AUTORESIZE_MIN - IMG_ROOT_SIZE) / 1024 / 1024 ))
    [[ "$diff" != '-'* ]] && diff="+${diff}" # add a + in case the value is not negative for formatting reasons
    debug 'DEBUG' "IMG_ROOT_SIZE=$IMG_ROOT_SIZE bytes | LOCAL_AUTORESIZE_MIN=$LOCAL_AUTORESIZE_MIN bytes | diff=${diff}MiB"

    if [ "$IMG_ROOT_SIZE" -lt "$LOCAL_AUTORESIZE_MIN" ] && (( LOCAL_AUTORESIZE_MIN - IMG_ROOT_SIZE >= 268435456 )); then # 256MiB in bytes
      DIFFERENCE="${diff}MiB, Expanding img filesystem"
      RESIZE_FUNCTION='expand'
    elif [ "$IMG_ROOT_SIZE" -gt "$LOCAL_AUTORESIZE_MIN" ] && (( IMG_ROOT_SIZE - LOCAL_AUTORESIZE_MIN >= 536870912 )); then # 512MiB in bytes
      DIFFERENCE="${diff}MiB, Shrinking img filesystem"
      RESIZE_FUNCTION='shrink'
    else
      if [[ "$diff" != '-'* ]]; then
        DIFFERENCE="Too small (${diff}MiB), not expanding filesystem (must be >=+256MiB)"
        diff_small=true
      else
        DIFFERENCE="Too small (${diff}MiB), not shrinking filesystem (must be >=-512MiB)"
        diff_small=true
      fi
    debug 'DEBUG' "DIFFERENCE=$DIFFERENCE"
    fi
  # Change TRUNCATE_TOTAL to be based on img file instead of local root if [extra space] is provided
  elif [ "$ADDED_SPACE" -ne 0 ]; then
    debug 'INFO' 'Manually added space provided by user, calculating img size (TRUNCATE_TOTAL) by adding ADDED_SPACE to IMG_SIZE'
    TRUNCATE_TOTAL=$(( ADDED_SPACE + IMG_SIZE ))
    debug 'DEBUG' "TRUNCATE_TOTAL=${TRUNCATE_TOTAL} bytes"
  fi

  # Display information
  echo -e "${Purple}${BREAK}"
  if [ "$PROMPTS" = false ]; then
    debug 'INFO' '-y selected by user. prompts are disabled'
    echo -e "# ${Yellow}DISABLE PROMPTS SELECTED (${Green}-y${Yellow}), NO WARNINGS ABOUT DELETION!!! ${Purple}$(printf "%+$(( COLS - 63 ))s" '#')"
  fi
  #echo -e "# ${IWhite}Updating ${Green}$IMG_FILE ${Purple}$(printf "%+$(( COLS - 11 - $(echo ${IMG_FILE} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Updating backup img: ${Purple}$(printf "%+$(( COLS - 23 ))s" '#')"
  echo -e "# ${Green}$IMG_FILE ${Purple}$(printf "%+$(( COLS - 2 - $(echo ${IMG_FILE} | wc -m ) ))s" '#')"
  echo -e "# ${Green}$FSTYPE ${IWhite}filesystem detected on root ${Purple}$(printf "%+$(( COLS - 30 - $(echo ${FSTYPE} | wc -m ) ))s" '#')"
  if [ "$RSYNC_DELETE" != '--delete' ]; then
    echo -e "# ${Green}--fix ${IWhite}option selected, ${Green}rsync using --delete-before & --fsync options${Purple}$(printf "%+$(( COLS - 70 ))s" '#')"
  fi
  if [ "$FSTYPE" == 'btrfs' ]; then
    echo -e "# ${Green}${#LOCAL_TOP_SUBVOLUMES[@]} ${IWhite}btrfs top volumes will be included ${Purple}$(printf "%+$(( COLS - 37 - $(echo ${#LOCAL_TOP_SUBVOLUMES[@]} | wc -m ) ))s" '#')"
    echo -e "${Purple}# ${IWhite}btrfs top volumes: ${Green}${LOCAL_TOP_SUBVOLUMES[@]} ${Purple}$(printf "%+$(( COLS - 21 - $(echo ${LOCAL_TOP_SUBVOLUMES[@]} | wc -m ) ))s" '#')"
    echo -e "# ${Green}${#LOCAL_NESTED_SUBVOLUMES[@]} ${IWhite}btrfs nested volumes will be included ${Purple}$(printf "%+$(( COLS - 40 - $(echo ${#LOCAL_NESTED_SUBVOLUMES[@]} | wc -m ) ))s" '#')"
    echo -e "${Purple}# ${IWhite}btrfs nested volumes: ${Green}${LOCAL_NESTED_SUBVOLUMES[@]} ${Purple}$(printf "%+$(( COLS - 24 - $(echo ${LOCAL_NESTED_SUBVOLUMES[@]} | wc -m ) ))s" '#')"
  elif [ "$FSTYPE" == 'f2fs' ]; then
    echo -e "# ${Yellow}Autoexpand filesystem at boot not available for ${Green}f2fs ${Purple}$(printf "%+$(( COLS - 54 ))s" '#')"
    echo -e "# ${Yellow}Resize operations not available for ${Green}f2fs ${Purple}$(printf "%+$(( COLS - 43 ))s" '#')"
  fi
  if [ "$RSYNC_DELETE" = '--delete-before' ]; then
    echo -e "# ${Green}--fix ${IWhite}option selected, rsync will delete files on img before copy ${Purple}$(printf "%+$(( COLS - 68 ))s" '#')"
    debug 'DEBUG' '--fix selected by user, rsync deleting files before copy'
  fi
  if [ "$RSYNC_CUSTOM" = true ]; then
    echo -e "# ${IWhite}Custom rsync line: ${Purple}$(printf "%+$(( COLS - 21 ))s" '#')"
    echo -e "  ${Green}$RSYNC_CUSTOM_LINE"
  fi
  echo -e "${Purple}# $(printf %$(( COLS - 4 ))s | tr ' ' '-') #"
  echo -e "# ${IWhite}Write to logfile:              ${Green}$DEBUG ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${DEBUG} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Zoom speed requested:          ${Green}$ZOOM ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${ZOOM} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}rsync tty output:              ${Green}$RSYNC_TTY ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${RSYNC_TTY} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Autocalculate img root size:   ${Green}$AUTORESIZE_RUN ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${AUTORESIZE_RUN} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Autoexpand filesystem at boot: ${Green}$AUTOEXPAND ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${AUTOEXPAND} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Use exclude.txt:               ${Green}$EXCLUDE_FILE ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${EXCLUDE_FILE} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Boot partition:                ${Green}$BOOT_PARTITION ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${BOOT_PARTITION} | wc -m ) ))s" '#')"
  print_temp="$(( LOCAL_BOOTSECTOR / 1024 / 1024 ))"
  echo -e "# ${IWhite}Bootsector size:               ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
  if [ "$AUTORESIZE_RUN" = true ]; then
    print_temp="$(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))"
    echo -e "# ${IWhite}Auto calculated root size:     ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
    print_temp="$(( IMG_SIZE / 1024 / 1024 ))"
    echo -e "# ${IWhite}Old img size:                  ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
    print_temp="$(( TRUNCATE_TOTAL / 1024 / 1024 ))"
    echo -e "# ${IWhite}New img size:                  ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
    if [ -z "$diff_small" ]; then
      echo -e "# ${IWhite}Difference:                   ${Green}$DIFFERENCE ${Purple}$(printf "%+$(( COLS - 32 - $(echo ${DIFFERENCE} | wc -m ) ))s" '#')"
    else
      echo -e "# ${IWhite}Difference: ${Green}$DIFFERENCE ${Purple}$(printf "%+$(( COLS - 14 - $(echo ${DIFFERENCE} | wc -m ) ))s" '#')"
    fi
  elif [ "$ADDED_SPACE" -ne 0 ]; then
    print_temp="$(( $(df / -k --sync --output=used | tail -1) / 1024 ))"
    echo -e "# ${IWhite}Estimated root usage:          ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
    print_temp="$(( ADDED_SPACE / 1024 / 1024 ))"
    echo -e "# ${IWhite}Added [extra space]:           ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
    print_temp="$(( IMG_SIZE / 1024 / 1024 ))"
    echo -e "# ${IWhite}Old img size:                  ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
    print_temp="$(( TRUNCATE_TOTAL / 1024 / 1024 ))"
    echo -e "# ${IWhite}New img size:                  ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
  else
    print_temp="$(( $(df / -k --sync --output=used | tail -1) / 1024 ))"
    echo -e "# ${IWhite}Estimated root usage:          ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
    print_temp="$(( IMG_SIZE / 1024 / 1024 ))"
    echo -e "# ${IWhite}Total img size:                ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 36 - $(echo ${print_temp} | wc -m ) ))s" '#')"
  fi
  echo -e "${Purple}${BREAK}${IWhite}"

  # Disabled prompts
  if [ "$PROMPTS" = false ] && [ "$ZOOM" = false ]; then
    echo -e "${Red}!! PRESS CTRL+C WITHIN 5s TO CANCEL !! $(printf "%+$(( COLS - 39 ))s" '#')"
    echo -e "${Red}${BREAK}"
    sleep 6
    debug 'INFO' '6 seconds passed, user did not stop operation'
    debug 'BREAK'

  # Confirm with user input
  elif [ "$PROMPTS" = true ]; then
    debug 'INFO' 'Do you want to continue? [y/n]'
    while true; do
      if [ "$COLORS" = true ]; then
        read -r -p $'\e[0;37m## \e[0;97mDo you want to continue? \e[0;92m[y/n] \e[0m' input
      else
        read -r -p '## Do you want to continue? [y/n] ' input
      fi
      case $input in
        [Yy]) break;;
        [Nn]) echo -e "${Red}!! Aborting..."; exit 4;;
        *) echo -e "${Yellow}!! ${Red}ERROR! ${Yellow}Please enter ${Green}'y' ${Yellow}or ${Green}'n'${Yellow}"; debug 'WARNING' "ERROR, please enter 'y' or 'n'";;
      esac
    done
    debug 'INFO' 'Y or y pressed to confirm'
    debug 'BREAK'
  fi

  # Resize if needed
  if [ "$AUTORESIZE_RUN" = true ]; then
    # Expanding
    if [ "$RESIZE_FUNCTION" == 'expand' ]; then
      debug 'INFO' "Running function: do_resize 'expand'"
      do_resize 'expand'

    # Shrink then exit this function
    elif [ "$RESIZE_FUNCTION" == 'shrink' ]; then
      debug 'INFO' 'Running function: do_mount'
      do_mount
      debug 'INFO' 'Backing up files'
      debug 'INFO' 'Running function: do_rsync'
      do_rsync
      debug 'INFO' "Running function: do_resize 'shrink'"
      do_resize 'shrink'
      if [ $FSTYPE == 'ext4' ]; then
        debug 'INFO' "Running function: do_e2fsck 'final'"
        do_e2fsck 'final'
      fi
      return 0

    else
      debug 'INFO' 'Img root partition is <=256MiB smaller or <=512MiB bigger compared to auto calculated size, not resizing'
    fi
  fi

  # Expand img file if ADDED_SPACE not 0
  if [ "$ADDED_SPACE" -ne 0 ]; then
    debug 'INFO' "Running function: do_resize 'expand'"
    do_resize 'expand'
  fi

  debug 'INFO' 'Running function: do_mount'
  do_mount
  debug 'INFO' 'Backing up files'
  debug 'INFO' 'Running function: do_rsync'
  do_rsync

  # Final check of img filesystem
  if [ $FSTYPE == 'ext4' ]; then
    debug 'INFO' "Running function: do_e2fsck 'final'"
    do_e2fsck 'final'
  fi
return 0
}



# Enable autoexpansion for Manjaro
function autoexpansion_manjaro() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.target.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi

  # Creating autoexpansion systemd unit file expand-fs.service
  debug 'DEBUG' 'Systemd unit expand-fs.service does not exist, creating it'
  cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/usr/bin/resize-fs || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /etc/systemd/system/expand-fs.service && /usr/bin/reboot -f || exit 0"

[Install]
WantedBy=basic.target
EOF

  if ! [ -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi

  echo -e "${White}## ${Green}Manjaro-arm filesystem autoresizing at boot..."
  debug 'INFO' 'Manjaro-arm filesystem autoresizing at boot'
  $SLEEPING
return 0
}



# Enable autoexpansion for Armbian
function autoexpansion_armbian() {
  if ! test -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service"; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /lib/systemd/system/armbian-resize-filesystem.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service"
    ln -s /lib/systemd/system/armbian-resize-filesystem.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service
  fi
  echo -e "${White}## ${Green}Armbian filesystem autoresizing at boot..."
  debug 'INFO' 'Armbian filesystem autoresizing at boot'
  $SLEEPING
return 0
}



# Enable autoexpansion for Raspberry pi
function autoexpansion_rpi() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.target.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi

  # Creating autoexpansion systemd unit file expand-fs.service
  debug 'DEBUG' 'Creating systemd unit expand-fs.service'
  cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/expand-fs.sh || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /expand-fs.sh && /usr/bin/rm /etc/systemd/system/expand-fs.service && /usr/sbin/reboot -f || exit 0"

[Install]
WantedBy=basic.target
EOF

  # Enable service by creating symlink
  if ! [ -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi

  # Creating script for autoexpansion
  debug 'DEBUG' "Creating expansion script ${TMP_DIR}/expand-fs.sh"
  cat << EOF2 > "${TMP_DIR}/expand-fs.sh"
#!/usr/bin/bash
LOCAL_DEV_ROOT_PATH=\$(findmnt -n -o SOURCE /)
LOCAL_DEV_PATH=/dev/\$(lsblk -no pkname "\$LOCAL_DEV_ROOT_PATH")
LOCAL_ROOT_PARTN=\$(blkid -s PART_ENTRY_NUMBER -o value -p "\$LOCAL_DEV_ROOT_PATH")
LOCAL_ROOT_START=\$(fdisk -lo start "\$LOCAL_DEV_PATH" | tail -1 | awk '{print \$1}') # blocks, 512B block size
LOCAL_ROOT_START=\$(( LOCAL_ROOT_START * 512 )) # bytes

sfdisk --delete -f "\$LOCAL_DEV_PATH" "\$LOCAL_ROOT_PARTN"
parted -s -a none "\$LOCAL_DEV_PATH" unit B mkpart primary "\$LOCAL_ROOT_START" 100%

resize2fs -f "\$LOCAL_DEV_ROOT_PATH"
sync
exit 0
EOF2

  debug 'DEBUG' 'Making expand-fs.sh executable'
  chmod +x ${TMP_DIR}/expand-fs.sh

  echo -e "${White}## ${Green}Raspberry pi filesystem autoresizing at boot..."
  debug 'INFO' 'Raspberry pi filesystem autoresizing at boot'
  $SLEEPING
return 0
}



# Enable autoexpansion for ArchLinuxArm
function autoexpansion_arch() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.target.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi

  # Creating autoexpansion systemd unit file expand-fs.service
  debug 'DEBUG' 'Creating systemd unit expand-fs.service'
  cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/expand-fs.sh || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /expand-fs.sh && /usr/bin/rm /etc/systemd/system/expand-fs.service && /usr/bin/reboot -f || exit 0"

[Install]
WantedBy=basic.target
EOF

  # Enable service by creating symlink
  if ! [ -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi

  # Creating script for autoexpansion
  debug 'DEBUG' "Creating expansion script ${TMP_DIR}/expand-fs.sh"
  cat << EOF2 > "${TMP_DIR}/expand-fs.sh"
#!/usr/bin/bash
LOCAL_DEV_ROOT_PATH=\$(findmnt -n -o SOURCE /)
LOCAL_DEV_PATH=/dev/\$(lsblk -no pkname "\$LOCAL_DEV_ROOT_PATH")
LOCAL_ROOT_PARTN=\$(blkid -s PART_ENTRY_NUMBER -o value -p "\$LOCAL_DEV_ROOT_PATH")
LOCAL_ROOT_START=\$(fdisk -lo start "\$LOCAL_DEV_PATH" | tail -1 | awk '{print \$1}') # blocks, 512B block size
LOCAL_ROOT_START=\$(( LOCAL_ROOT_START * 512 )) # bytes

sfdisk --delete -f "\$LOCAL_DEV_PATH" "\$LOCAL_ROOT_PARTN"
parted -s -a none "\$LOCAL_DEV_PATH" unit B mkpart primary "\$LOCAL_ROOT_START" 100%
resize2fs -f "\$LOCAL_DEV_ROOT_PATH"
sync
exit 0
EOF2

  debug 'DEBUG' 'Making /expand-fs.sh executable'
  chmod +x ${TMP_DIR}/expand-fs.sh

  echo -e "${White}## ${Green}ArchLinux-arm filesystem autoresizing at boot..."
  debug 'INFO' 'ArchLinux-arm filesystem autoresizing at boot'
  $SLEEPING
return 0
}



# Enable autoexpansion for Kali-ARM
function autoexpansion_kali() {
  if ! test -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/rpi-resizerootfs.service"; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /etc/systemd/system/rpi-resizerootfs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/rpi-resizerootfs.service"
    ln -s /etc/systemd/system/rpi-resizerootfs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/rpi-resizerootfs.service
  fi
  echo -e "${White}## ${Green}Kali-ARM filesystem autoresizing at boot..."
  debug 'INFO' 'Kali-ARM filesystem autoresizing at boot'
  $SLEEPING
return 0
}



# Print result
function print_result() {

  AFTER_SIZE=$(stat -c %s "$IMG_FILE")
  AFTER_SIZE=$(( AFTER_SIZE / 1024 / 1024 ))
  IMG_ROOT_SIZE=$(fdisk --bytes -lo device,size "$LOOP" | grep "$IMG_DEV_ROOT_PATH" | awk '{print $2}' )

  echo -e "${White}## ${Green}Backup done."
  echo -e "${Purple}${BREAK}"
  echo -e "# ${IWhite}Backup location: ${Green}${IMG_FILE} ${Purple}$(printf "%+$(( COLS - 19 - $(echo ${IMG_FILE} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Write to logfile: ${Green}$DEBUG ${Purple}$(printf "%+$(( COLS - 20 - $(echo ${DEBUG} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Autoexpand filesystem at boot: ${Green}$AUTOEXPAND ${Purple}$(printf "%+$(( COLS - 33 - $(echo ${AUTOEXPAND} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Use exclude.txt: ${Green}$EXCLUDE_FILE ${Purple}$(printf "%+$(( COLS - 19 - $(echo ${EXCLUDE_FILE} | wc -m ) ))s" '#')"
  echo -e "# ${IWhite}Boot partition: ${Green}$BOOT_PARTITION ${Purple}$(printf "%+$(( COLS - 18 - $(echo ${BOOT_PARTITION} | wc -m ) ))s" '#')"
  print_temp="$(( LOCAL_BOOTSECTOR / 1024 / 1024 ))"
  echo -e "# ${IWhite}Bootsector size: ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 22 - $(echo ${print_temp} | wc -m ) ))s" '#')"
  print_temp="$(( $(df / -k --sync --output=used | tail -1) / 1024 ))"
  echo -e "# ${IWhite}Estimated root usage: ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 27 - $(echo ${print_temp} | wc -m ) ))s" '#')"

  # New backup
  if [ "$UPDATE" = false ]; then
    debug 'INFO' 'Img file created'
    if [ "$AUTORESIZE_RUN" = true ]; then
      print_temp="$(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))"
      echo -e "# ${IWhite}Image size: ${Green}${AFTER_SIZE}MiB ${IWhite}with a ${Green}root partition ${IWhite}of ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 45 - $(echo ${AFTER_SIZE} | wc -m ) - $(echo ${print_temp} | wc -m ) ))s" '#')"
      debug 'DEBUG' "$IMG_FILE is ${AFTER_SIZE}MiB with a root partition of $(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))MiB"
    else
      print_temp="$(( ADDED_SPACE / 1024 / 1024 ))"
      echo -e "# ${IWhite}Added [extra space]: ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 26 - $(echo ${print_temp} | wc -m ) ))s" '#')"
      print_temp=$(( IMG_ROOT_SIZE / 1024 / 1024 ))
      echo -e "# ${IWhite}Image size: ${Green}${AFTER_SIZE}MiB ${IWhite}with a ${Green}root partition ${IWhite}of ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 45 - $(echo ${AFTER_SIZE} | wc -m ) - $(echo ${print_temp} | wc -m ) ))s" '#')"
      debug 'DEBUG' "$IMG_FILE is ${AFTER_SIZE}MiB with a root partition of ${print_temp}MiB including $(( ADDED_SPACE / 1024 / 1024 ))MiB [extra space]"
    fi

  # Updated backup
  else
    debug 'INFO' 'Img file updated'
    if [ "$ADDED_SPACE" -ne 0 ]; then
      print_temp="$(( ADDED_SPACE / 1024 / 1024 ))"
      echo -e "# ${IWhite}Added [extra space]: ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 26 - $(echo ${print_temp} | wc -m ) ))s" '#')"
    fi
    print_temp=$(( IMG_ROOT_SIZE / 1024 / 1024 ))
    echo -e "# ${IWhite}Image size: ${Green}${AFTER_SIZE}MiB ${IWhite}with a ${Green}root partition ${IWhite}of ${Green}${print_temp}MiB ${Purple}$(printf "%+$(( COLS - 45 - $(echo ${AFTER_SIZE} | wc -m ) - $(echo ${print_temp} | wc -m ) ))s" '#')"
    debug 'INFO' "$IMG_FILE is ${AFTER_SIZE}MiB"
  fi
  if [ "$AUTOEXPAND" = true ] && [ "$OS" != 'armbian' ] && [ "$OS" != 'kali' ] && [ "$OS" != 'ubuntu' ]; then
    echo -e "# ${Yellow}Please wait for the system to reboot after restoring an image with autoexpansion ${Purple}$(printf "%+$(( COLS - 83 ))s" '#')"
  fi
  echo -e "${Purple}${BREAK}"
  debug 'INFO' 'Backup done'
  debug 'BREAK'
return 0
}



# Check if debugging is requested
if [ "$DEBUG" = true ]; then
  echo -e "${White}## ${IWhite}Debugging requested, writing to log file: ${Green}$LOG_FILE"
  debug 'INFO' "Debugging requested, writing to log file $LOG_FILE"
fi

debug 'INFO' "Version=$VERSION"
debug 'INFO' "Script started with: $STARTLINE"

# Make sure absolute path is used on img file
if ! [[ "$IMG_FILE" =~ ^[/|.] ]]; then
  debug 'INFO' 'Absolute path not provided for img file, adding pwd to variable'
  IMG_FILE="$(pwd)/$IMG_FILE"
elif [[ "$IMG_FILE" =~ ^[.] ]]; then
  debug 'INFO' 'Path to img file starting with ".", removing dot adding pwd to variable'
  IMG_FILE="$(pwd)${IMG_FILE:1}"
fi

# Set zoom type
if [ "$ZOOM" = false ]; then
  SLEEPING='sleep 1'
  echo -e "${White}## ${IWhite}Zoom speed NOT requested..."
  debug 'INFO' "Zoom speed NOT requested, setting SLEEPING=$SLEEPING | ZOOM=$ZOOM"
  $SLEEPING
else
  SLEEPING=''
  echo -e "${White}## ${IWhite}Zoom speed requested..."
  debug 'INFO' "Zoom speed requested, setting SLEEPING to empty variable | ZOOM=$ZOOM"
fi

# Check if the image file has the correct extension
if [ "$LOOPRUN" = false ] && [[ "$IMG_FILE" != *.img ]]; then
  echo -e "${Red}!! ERROR! ${Yellow}File must have ${Green}.img ${Yellow}extension"
  debug 'ERROR' 'File must have .img extension, exit 1'
  exit 1
fi

# Setting ADDED_SPACE to 0 if AUTORESIZE_RUN option is enabled
if [ "$AUTORESIZE_RUN" = true ] && [ "$LOOPRUN" = false ]; then
  if [ -n "$ADDED_SPACE" ]; then
    echo -e "${Yellow}!! ${Green}-a ${Yellow}used in combination with ${Green}[extra space]"
    echo -e "${Yellow}!! ${Green}[extra space] (${ADDED_SPACE}MiB) ${Yellow}is ingored!"
    $SLEEPING
  fi
  ADDED_SPACE=0
  debug 'INFO' '-a selected by user, setting ADDED_SPACE to 0 (non-zero value)'
fi

# Setting ADDED_SPACE to 0 if update is requested and variable ADDED_SPACE is a zero value
if [ $UPDATE = true ] && [ -z "$ADDED_SPACE" ] && [ "$LOOPRUN" = false ]; then
  ADDED_SPACE=0
  debug 'INFO' '-U selected, -a not selected or [extra space] not provided by user, setting ADDED_SPACE to 0 (non-zero value)'
fi

# Setting ADDED_SPACE to 0 if --loop is selected without providing [extra space]
if [ "$LOOPRUN" = true ] && [ -z "$ADDED_SPACE" ]; then
  ADDED_SPACE=0
  debug 'INFO' '--loop selected and [extra space] not provided by user, setting ADDED_SPACE to 0 (non-zero value)'
fi

# Setting ADDED_SPACE to 0 if --chroot is selected
if [ "$CHROOTRUN" = true ]; then
  ADDED_SPACE=0
  debug 'INFO' '--chroot selected, setting ADDED_SPACE to 0 (non-zero value)'
fi

# Requesting user to input [extra space] if not provided while making new image
if [ "$UPDATE" = false ] && [ -z "$ADDED_SPACE" ]; then
  debug 'INFO' 'New image without -a option and no [extra space] defined by user, requesting user input'
  echo -e "${White}## ${IWhite}New image requested without ${Yellow}-a ${IWhite}option and no provided ${Yellow}[extra space]"
  if [ "$COLORS" = true ]; then
    read -r -p $'\e[0;37m## \e[0;97mPlease input requested \e[0;92m[extra space] in MiB \e[0;97m(0 is valid): ' ADDED_SPACE
  else
    read -r -p '## Please input requested [extra space] in MiB (0 is valid): ' ADDED_SPACE
  fi
  debug 'DEBUG' "User requested ${ADDED_SPACE}MiB as ADDED_SPACE"
fi

# Regular expression for whole numbers
RE='^[0-9]+$'

# Validate the added space argument as a whole number
if ! [[ "$ADDED_SPACE" =~ $RE ]]; then
  debug 'WARNING' 'User defined ADDED_SPACE is not a regualar expression (whole number)'
  debug 'DEBUG' "ADDED_SPACE=$ADDED_SPACE"
  COUNTER=0
  while ! [[ "$ADDED_SPACE" =~ $RE ]]
  do
    if [ "$COUNTER" -gt 0 ]; then
      echo -e "${Yellow}!! ${Red}ERROR!"
      debug 'WARNING' 'ERROR, user input ADDED_SPACE not regular expression'
    fi
    echo -e "${Yellow}!! [extra space] space must be a whole number"
    echo -e "${Yellow}## How much space in MiB should be added to the image? (0 is valid)"
    read ADDED_SPACE
    (( COUNTER++ ))
    #(( COUNTER += 1 ))
    debug 'DEBUG' "User requested ${ADDED_SPACE}MiB as ADDED_SPACE"
  done
  typeset -i ADDED_SPACE
fi

# If boot exists in fstab, set BOOT_PATH and make sure boot is mounted
if grep -q 'boot' /etc/fstab; then
  debug 'INFO' 'Separate boot partition detected'
  BOOT_PATH=$(cat /etc/fstab | grep 'boot' | awk '{print $2}') # Used in cleanup function
  debug 'DEBUG' "BOOT_PATH=$BOOT_PATH"
  if ! mount --fake | grep -q 'boot'; then
    echo -e "${Red}!! Boot found in fstab but partition not mounted..."
    debug 'WARNING' 'Boot found in fstab but partition not mounted'
    $SLEEPING
    fstab=($(cat /etc/fstab | grep 'boot'))
    if [ "$PROMPTS" = true ]; then
      while true; do
        if [ "$COLORS" = true ]; then
          debug 'INFO' 'Do you want to mount boot partition?'
          read -r -p $'\e[0;37m## \e[0;97mDo you want to mount boot partition? \e[0;92m[y/n] \e[0m' input
        else
          read -r -p '## Do you want to mount boot partition? [y/n] ' input
        fi
        case $input in
          [Yy]) debug 'DEBUG' "Y or y pressed to confirm, running: mount ${fstab[0]} ${fstab[1]}"; echo -e "${Yellow}!! Mounting boot partition to ${fstab[1]}..."; mount "${fstab[0]}" "${fstab[1]}"; break;;
          [Nn]) echo -e "${Red}!! Aborting..."; exit 4;;
          *) echo -e "${Yellow}!! ${Red}ERROR! ${Yellow}Please enter ${Green}'y' ${Yellow}or ${Green}'n'${Yellow}"; debug 'WARNING' "ERROR, please enter 'y' or 'n'";;
        esac
      done
    else
      echo -e "${Yellow}!! Mounting boot partition to ${fstab[1]}..."
      debug 'DEBUG' "Running: mount ${fstab[0]} ${fstab[1]}"
      mount "${fstab[0]}" "${fstab[1]}"
    fi
  sleep 1
  fi

  # Create a lock file on boot partition and tail it to hinder unmount operations
  touch "$BOOT_PATH"/shrink-backup.lock
  tail -f "$BOOT_PATH"/shrink-backup.lock > /dev/null &
  debug 'DEBUG' "${BOOT_PATH}/shrink-backup.lock created, running: tail -f ${BOOT_PATH}/shrink-backup.lock > /dev/null &"
fi

# If --loop is requested, execute looprun function. Will exit script within the function
if [ "$LOOPRUN" = true ]; then
  debug 'INFO' 'Running function: looprun'
  looprun
fi

# If --chroot is requested, execute chrootrun function. Will exit script within the function
if [ "$CHROOTRUN" = true ]; then
  debug 'INFO' 'Running function: chrootrun'
  chrootrun
fi

echo -e "${White}## ${IWhite}Scanning filesystem and calculating..."

# Check what filesystem root is using and set LOCAL_DEV_PATH & PARTITION_TABLE
FSTYPE="$(mount --fake | grep ' / ' | awk '{print $5}')"
debug 'INFO' "$FSTYPE root filesystem detected"
debug 'DEBUG' "FSTYPE=$FSTYPE"
if [ "$FSTYPE" == 'ext4' ] || [ "$FSTYPE" == 'f2fs' ]; then
  LOCAL_DEV_PTUUID=$(lsblk -no mountpoint,ptuuid | grep '/ ' | awk '{print $2}')
elif [ "$FSTYPE" == 'btrfs' ]; then
  #LOCAL_DEV_PTUUID=$(lsblk -no fsroots,ptuuid | grep '/ ' | awk '{print $2}')
  LOCAL_DEV_PTUUID=$(lsblk -no path,ptuuid $(mount --fake | grep ' / ' | awk '{print $1}') | awk '{print $2}')
fi
LOCAL_DEV_PATH=$(lsblk -no ptuuid,type,path | grep "$LOCAL_DEV_PTUUID" | grep 'disk' | awk '{print $3}' | head -1)
debug 'DEBUG' "LOCAL_DEV_PTUUID=$LOCAL_DEV_PTUUID | LOCAL_DEV_PATH=$LOCAL_DEV_PATH"
PARTITION_TABLE=$(parted "$LOCAL_DEV_PATH" print | grep -i 'Partition Table' | awk '{print $3}')
#PARTITION_TABLE=$(blkid "$LOCAL_DEV_PATH" | sed -n 's|^.*PTTYPE="\(\S\+\)".*|\1|p')

if [ "$FSTYPE" == 'f2fs' ] || [ "$F2FS_CONVERSION" = true ]; then
  if [ "$FSTYPE" == 'f2fs' ] && [ "$F2FS_CONVERSION" = true ]; then
    echo -e "${Red}!! ERROR! ${Green}--f2fs ${Yellow}selected with existing ${Green}f2fs filesystem${Yellow}, conversion not needed"
    echo -e "${Red}!! Run script without ${Green}--f2fs"
    debug 'ERROR' '--f2fs selected with existing f2fs filesystem, conversion not needed, exit 1'
    exit 1
  elif [ "$F2FS_CONVERSION" = true ] && [ "$UPDATE" = true ]; then
    echo -e "${Red}!! ERROR! ${Green}--f2fs ${Yellow}selected in combination with ${Green}-U${Yellow}, conversion not possible"
    echo -e "${Red}!! ${Yellow}Create new img to enable ${Green}f2fs conversion"
    debug 'ERROR' '--f2fs selected in combination with -U, operation not supported, exit 1'
    exit 1
  elif [ "$FSTYPE" == 'f2fs' ] && [ "$UPDATE" = true ] && [ "$AUTORESIZE_RUN" = true ]; then
    echo -e "${Red}!! ERROR! ${Green}-U ${Yellow}selected in combination with ${Green}-a${Yellow}, operation not supported"
    echo -e "${Red}!! ${Yellow}Only creation of new img backups support ${Green}operations with -a when using f2fs on root"
    debug 'ERROR' '-U selected in combination with -a on f2fs filesystem, operation not supported, exit 1'
    exit 1
  elif [ "$FSTYPE" == 'f2fs' ] && [ "$UPDATE" = true ] && [ "$ADDED_SPACE" -ne 0 ]; then
    echo -e "${Red}!! ERROR! ${Green}-U ${Yellow}selected in combination with ${Green}[extra space]${Yellow}, operation not supported"
    echo -e "${Red}!! ${Yellow}Only creation of new img backups support ${Green}operations with [extra space] when using f2fs on root"
    debug 'ERROR' '-U selected in combination with [extra space] on f2fs filesystem, operation not supported, exit 1'
    exit 1
  fi
  debug 'INFO' 'f2fs filesystem or conversion to f2fs requested, disabling autoexpansion'
  AUTOEXPAND=false
fi

# Detect OS
if [ -e /etc/apt/sources.list.d/raspi.list ]; then
  echo -e "${White}## ${Green}Raspberry pi detected"
  OS='rpi'
  debug 'INFO' 'Raspberry pi detected'
  $SLEEPING
elif [ -e /etc/armbian-release ] || grep -qsi 'armbian' /etc/os-release; then
  echo -e "${White}## ${Green}Armbian detected"
  OS='armbian'
  debug 'INFO' 'Armbian detected'
  $SLEEPING
elif grep -qsi 'manjaro' /etc/os-release; then
  echo -e "${White}## ${Green}Manjaro-arm detected"
  OS='manjaro-arm'
  debug 'INFO' 'Manjaro-arm detected'
  $SLEEPING
elif grep -qsi 'archlinuxarm' /etc/os-release; then
  echo -e "${White}## ${Green}ArchLinux-arm detected"
  OS='archlinux-arm'
  debug 'INFO' 'ArchLinux-arm detected'
  $SLEEPING
elif grep -qsi 'kali' /etc/os-release; then
  echo -e "${White}## ${Green}Kali-arm detected"
  OS='kali'
  debug 'INFO' 'Kali-arm detected'
  $SLEEPING
elif grep -qsi 'ubuntu' /etc/os-release; then
  echo -e "${White}## ${Green}Ubuntu detected"
  OS='ubuntu'
  debug 'INFO' 'Ubuntu detected'
  $SLEEPING
else
  echo -e "${Yellow}!! Unknown OS, no autoexpansion available"
  OS='unknown'
  debug 'INFO' 'Unknown OS'
  $SLEEPING
fi

# Enter variables into logfile
if [ "$DEBUG" = true ]; then
  debug 'BREAK'
  debug 'DEBUG' "INSTALL_METHOD=$INSTALL_METHOD"
  debug 'DEBUG' "OS=$OS"
  debug 'DEBUG' "IMG_FILE=$IMG_FILE"
  debug 'DEBUG' "PARTITION_TABLE=$PARTITION_TABLE"
  debug 'DEBUG' "UPDATE=$UPDATE"
  debug 'DEBUG' "AUTORESIZE_RUN=$AUTORESIZE_RUN"
  debug 'DEBUG' "PROMPTS=$PROMPTS"
  debug 'DEBUG' "RSYNC_TTY=$RSYNC_TTY"
  debug 'DEBUG' "EXCLUDE_FILE=$EXCLUDE_FILE"
  debug 'DEBUG' "AUTOEXPAND=$AUTOEXPAND"
  debug 'DEBUG' "RSYNC_DELETE=$RSYNC_DELETE"
  debug 'DEBUG' "RSYNC_CUSTOM=$RSYNC_CUSTOM"
  debug 'DEBUG' "F2FS_CONVERSION=$F2FS_CONVERSION"
  debug 'DEBUG' "TTY_AVAILABILITY=$TTY_AVAILABILITY"
  debug 'DEBUG' "ADDED_SPACE=$ADDED_SPACE"
  debug 'BREAK'
fi

# Check if exclude.txt exists when usage is requested
if [ "$EXCLUDE_FILE" = true ]; then
  debug 'INFO' "-t selected by user, using $EXCLUDE_FILE_LOCATION"
  if ! [ -f "$EXCLUDE_FILE_LOCATION" ]; then
    echo -e "${Red}!! ERROR! ${Green}-t selected but ${Yellow}$EXCLUDE_FILE_LOCATION does not exist!"
    debug 'ERROR' "$EXCLUDE_FILE_LOCATION does not exist, exit 1"
    exit 1
  fi
  debug 'DEBUG' "$EXCLUDE_FILE_LOCATION exists"
else
  debug 'INFO' '-t NOT selected by user, using default exclude directories'
fi

# Check dependencies
debug 'INFO' 'Running function: check_dependencies'
check_dependencies

# Create or update image
if [ "$UPDATE" != true ]; then
  debug 'INFO' 'Running function: make_img'
  debug 'BREAK'
  make_img
else
  debug 'INFO' '-U selected by user, running function: update_img'
  debug 'BREAK'
  update_img
fi

# Run autoexpansion
if [ "$AUTOEXPAND" = true ]; then
  debug 'INFO' 'Running autoexpand function'
  $SLEEPING
  case "$OS" in
    rpi) echo -e "${White}## ${IWhite}Enabling autoexpansion for ${Green}Raspberry pi..."; debug 'INFO' 'Running function: autoexpansion_rpi'; autoexpansion_rpi;;
    armbian) echo -e "${White}## ${IWhite}Enabling autoexpansion for ${Green}Armbian..."; debug 'INFO' 'Running function: autoexpansion_armbian'; autoexpansion_armbian;;
    manjaro-arm) echo -e "${White}## ${IWhite}Enabling autoexpansion for ${Green}Manjaro-arm..."; debug 'INFO' 'Running function: autoexpansion_manjaro'; autoexpansion_manjaro;;
    archlinux-arm) echo -e "${White}## ${IWhite}Enabling autoexpansion for ${Green}ArchLinux-arm..."; debug 'INFO' 'Running function: autoexpansion_arch'; autoexpansion_arch;;
    kali) echo -e "${White}## ${IWhite}Enabling autoexpansion for ${Green}Kali-ARM..."; debug 'INFO' 'Running function: autoexpansion_kali'; autoexpansion_kali;;
    ubuntu) echo -e "${White}## ${Green}Making sure autoexpansion is enabled in /etc/cloud/cloud.cfg on img"; debug 'INFO' "Making sure autoexpansion is enabled in ${TMP_DIR}/etc/cloud/cloud.cfg"
      sed -i 's/^[# ]*- growpart/  - growpart/' ${TMP_DIR}/etc/cloud/cloud.cfg
      sed -i 's/^[# ]*- resizefs/  - resizefs/' ${TMP_DIR}/etc/cloud/cloud.cfg;;
    unknown) echo -e "${Yellow}!! No autoexpand option available for this OS!"; debug 'WARNING' 'No autoexpand option available for this OS'; AUTOEXPAND='failed';;
  esac
elif [ "$AUTOEXPAND" = false ] && [ "$OS" == 'ubuntu' ]; then
  debug 'INFO' "Disable autoexpansion requested & Ubuntu detected, making sure autoexpansion is disabled in ${TMP_DIR}/etc/cloud/cloud.cfg"
  echo -e "${White}## ${Green}Making sure autoexpansion is disabled in /etc/cloud/cloud.cfg on img"
  $SLEEPING
  sed -i 's/^[ ]*- growpart/# - growpart/' ${TMP_DIR}/etc/cloud/cloud.cfg
  sed -i 's/^[ ]*- resizefs/# - resizefs/' ${TMP_DIR}/etc/cloud/cloud.cfg
fi

print_result

exit 0
