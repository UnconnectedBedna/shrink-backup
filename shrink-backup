#!/usr/bin/env bash
#
# shrink-backup
# version 1.0.0
# backup tool for backing up and updating .img files with autoexpansion on various operating systems
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    04/2024
#    Marcus Johansson
#    https://github.com/UnconnectedBedna/shrink-backup
##############################################################################

# Function to clean up resources on script exit or termination
function cleanup() {
  # exit 0 = cleanup after script
  # exit 1 = later/normal error
  # exit 2 = help & looprun
  # exit 3 = early/clean error
  # exit 4 = abort early
  # exit 5 = abort later
  # exit 10 = stopped by user mid script
  local exit_code="$?"

  if [ "$exit_code" -ne 2 ]; then

    if [ "$exit_code" -eq 0 ]; then
      debug 'DEBUG' 'Cleanup function called with exit 0'
    elif [ "$exit_code" -eq 3 ]; then
      debug 'WARNING' 'Early error, cleanup exit 3'
    elif [ "$exit_code" -eq 4 ]; then
      debug 'WARNING' 'Script aborted by user early, cleanup exit 4'
    elif [ "$exit_code" -eq 5 ]; then
      debug 'WARNING' 'Script aborted by user later, cleanup exit 5'
    elif [ "$exit_code" -eq 10 ]; then
      echo -e '\n## Script stopped by user...'
      debug 'WARNING' 'Script stopped by user with ctrl+c, cleanup exit 10'
    elif [ "$exit_code" -ne 0 ]; then
      echo '## Cleanup function called with non zero exit code, something went wrong!!!'
      debug 'ERROR' "Cleanup function called with non zero exit code: exit $exit_code"
    fi

    echo '## Exiting and cleaning up...'
    echo '## Please stand by...'

    if [ -n "$BOOT_PATH" ] && [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}${BOOT_PATH} " /proc/mounts; then
      umount "${TMP_DIR}${BOOT_PATH}"
      debug 'DEBUG' "Unmounting boot partition in cleanup function: umount ${TMP_DIR}${BOOT_PATH}"
    fi
    if [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}/home " /proc/mounts; then
      umount "$TMP_DIR"/home
      debug 'DEBUG' "Unmounting home partition in cleanup function: umount ${TMP_DIR}/home"
    fi
    if [ -n "$TMP_DIR" ] && grep -qs "$TMP_DIR " /proc/mounts; then
      umount "$TMP_DIR"
      debug 'DEBUG' "Unmounting root partition in cleanup function: umount $TMP_DIR"
    fi
    if losetup "$LOOP" &>/dev/null; then
      losetup -d "$LOOP"
      debug 'DEBUG' "Removing loop in cleanup function: losetup -d $LOOP"
    fi
    if [ -d "$TMP_DIR" ]; then
      rm -rf "$TMP_DIR"
      debug 'DEBUG' "Removing temp directory in cleanup function: rm -rf $TMP_DIR"
    fi
    if [ -f "$tmp_file" ]; then
      rm "$tmp_file"
      debug 'DEBUG' "Removing temp file in cleanup function: rm $tmp_file"
    fi

    echo '## Done.'
    echo "## Elapsed time: $(date -d@$SECONDS -u +%M.%S)"
    debug 'INFO' "Elapsed time: $(date -d@$SECONDS -u +%M.%S)"
    debug 'DEBUG' 'Exiting script'
    if [ "$DEBUG" == true ]; then
      echo '##############################################################################' >> "$LOG_FILE"
    fi
  fi
}
trap cleanup EXIT SIGTERM
trap "exit 10" SIGINT

# Function to pause script execution and prompt for user input
function pause() {
  read -p "$*"
}

# Uncomment the following line to enable the pause function
#pause 'Press [Enter] key to continue...'

# Set default values for script options
PROMPTS=true
DEBUG=false
EXCLUDE_FILE=false
AUTOEXPAND=true
RESIZE2FS_RUN=false
UPDATE=false
LOG_FILE="$(dirname "$0")/shrink-backup.log"
RESIZE2FS_WARNING=false
ZOOM=false
LOOPRUN=false
RSYNC_DELETE='--delete'
IS_LOOPED=false
RESIZE_RUN=false
# Check if running interactively
if [ -t 0 ]; then
  LOG_TARGET="/dev/tty"
else
  LOG_TARGET="$LOG_FILE"
fi

# Function to display help information
help() {
  local help
  read -r -d '' help << EOM
Script for creating an .img file and subsequently keeing it updated (-U), autoexpansion is enabled by default
Directory where .img file is created is automatically excluded in backup
########################################################################
Usage: sudo $(basename "$0") [-Uatyelzh] [--fix] [--loop] imagefile.img [extra space (MiB)]
  -U            Update existing img file (rsync to existing img)
                  [extra space] extends img size/root partition
  -a            Autoresize root partition (extra space is ignored)
                  When used in combination with -U:
                  Expand if partition is >=256MiB smaller than resize2fs recommended minimum
                  Shrink if partition is >=512MiB bigger than resize2fs recommended minimum
  -t            Use exclude.txt in same folder as script to set excluded directories
                  One directory per line: "/dir" or "/dir/*" to only exclude contents
  -y            Disable prompts in script (please use this option with care!)
  -e            DO NOT expand filesystem when image is booted
  -l            Write debug messages in logfile shrink-backup.log located in same directory as script
  -z            Make script zoom at light-speed, only question prompts might slow it down
                  Can be combined with -y for UNSAFE ultra mega superduper speed
  --fix         Try to fix the img file if -a fails with a "broken pipe" error
  --loop [img]  Loop img file and exit, works in combination with -l & -z
                  If [extra space] is also defined, the img file will be extended with the amount before looping
                  NOTE that only the file gets truncated, no partitions
                  Useful for example if you want to manually manage the partitions
  -h --help     Show this help snippet
########################################################################
Examples:
sudo $(basename "$0") -a /path/to/backup.img (create img, automatically set size)
sudo $(basename "$0") -e -y /path/to/backup.img 1024 (create img, ignore prompts, do NOT autoexpand, add 1024MiB extra space)
sudo $(basename "$0") -Utl /path/to/backup.img (update img backup, use exclude.txt and write log to shrink-backup.log)
sudo $(basename "$0") -Ua /path/to/backup.img (update img backup, automatically resizes img file if needed)
sudo $(basename "$0") -U /path/to/backup.img 1024 (update img backup, expand img size/root partition with 1024MiB)
sudo $(basename "$0") -l --loop /path/to/backup.img 1024 (write to log file, expand IMG FILE (not partition) by 1024MiB and loop)
EOM
  echo "$help"
  exit 2
}

# Parse command-line options
# Call getopt to validate the provided input.
options=$(getopt -o Uatyelzh --long help,fix,loop: -- "$@")
[ $? -eq 0 ] || {
    echo "Incorrect options provided"
    help
}
eval set -- "$options"
while true; do
  case "$1" in
    -U) UPDATE=true; shift;;
    -a) RESIZE2FS_RUN=true; RESIZE_RUN=true; shift;;
    -t) EXCLUDE_FILE=true; shift;;
    -y) PROMPTS=false; shift;;
    -e) AUTOEXPAND=false; shift;;
    -l) DEBUG=true; shift;;
    -z) ZOOM=true; shift;;
    -h | --help) help; break;;
    --fix) RSYNC_DELETE='--delete-before'; shift;;
    --loop) LOOPRUN=true; IMG_FILE="$2"; shift 2;;
    --) shift; break;;
    *) shift;;
  esac
done

# Check if script is run as root
if [ "$EUID" != 0 ]; then
  echo 'THIS SCRIPT MUST BE RUN AS ROOT! (WITH SUDO)'
  help
fi

function debug() {
  local log_level="$1"
  local log_message="$2"
  if [ "$DEBUG" == true ]; then
    if [ "$log_level" == 'BREAK' ]; then
      echo '------------------------------------------------------------------------------' >> "$LOG_FILE"
    else
      if [ $log_level == 'INFO' ]; then
        echo -e "$(date +"%Y-%m-%d %H:%M:%S") [$log_level]  - $log_message" >> "$LOG_FILE"
      else
        echo -e "$(date +"%Y-%m-%d %H:%M:%S") [$log_level] - $log_message" >> "$LOG_FILE"
      fi
    fi
  fi
  return 0
}



# Function to loop the img file and exit
function looprun() {

  if [ -n "$ADDED_SPACE" ]; then
    echo "## Extra space detected, truncating file by adding ${ADDED_SPACE}MiB"
    $SLEEPING
    truncate -s +$(( ADDED_SPACE * 1024 * 1024 )) "$IMG_FILE"
  fi

  debug 'INFO' 'Running function: do_loop'
  $SLEEPING
  do_loop

  echo "## $IMG_FILE is looped to $LOOP"
  echo '##############################################################################'
  echo "$(lsblk $LOOP)"
  echo '##############################################################################'
  echo '## Done.'

  debug 'DEBUG' 'Exiting script, exit 2'
  if [ "$DEBUG" == true ]; then
    echo '##############################################################################' >> "$LOG_FILE"
  fi

exit 2
}



# Function to gather device information
function get_dev_variables() {

  if [ "$FSTYPE" == 'btrfs' ] && [ "$RESIZE2FS_RUN" == false ] && [ "$ADDED_SPACE" -eq 0 ]; then
    debug 'INFO' 'Running function: get_btrfs_variables'
    get_btrfs_variables
    return 0
  fi

  ADDED_SPACE=$(( ADDED_SPACE * 1024 * 1024 )) # bytes, ADDED_SPACE=0 if RESIZE2FS_RUN=true

  # Check if separate boot and root partition exists and set variables accordingly
  #if [ $(lsblk | grep -c 'boot') -ne 0 ]; then
  if $(cat /etc/fstab | grep -q 'boot'); then
    debug 'INFO' 'Separate boot partition detected'
    LOCAL_DEV_BOOT_PATH=$(lsblk -lpo mountpoint,path | grep 'boot' | awk '{print $2}')
    LOCAL_DEV_ROOT_PATH=$(mount | grep '/ ' | awk '{print $1}')
    debug 'DEBUG' "LOCAL_DEV_BOOT_PATH=$LOCAL_DEV_BOOT_PATH | LOCAL_DEV_ROOT_PATH=$LOCAL_DEV_ROOT_PATH"
  else
    debug 'INFO' 'No boot partition detected'
    #LOCAL_DEV_ROOT_PATH=$(lsblk -lpo mountpoint,path | grep '/ ' | awk '{print $2}')
    LOCAL_DEV_ROOT_PATH=$(mount | grep '/ ' | awk '{print $1}')
    debug 'DEBUG' "LOCAL_DEV_ROOT_PATH=$LOCAL_DEV_ROOT_PATH"
  fi
  LOCAL_ROOT_PARTN=$(parted -sm "$LOCAL_DEV_PATH" print | tail -1 | cut -d : -f 1)
  debug 'DEBUG' "LOCAL_ROOT_PARTN=$LOCAL_ROOT_PARTN"

  if [ "$UPDATE" == false ] || [ "$RESIZE_RUN" == true ]; then
    # Collecting data and making calculations
    debug 'INFO' 'Calculating size for dd to cover bootsector in blocks (512B block size) and adding 256 blocks to overlap into root (only used in img creation)'
    debug 'DEBUG' "Running: fdisk -lo start "$LOCAL_DEV_PATH" | tail -1"
    LOCAL_ROOT_START=$(fdisk -lo start "$LOCAL_DEV_PATH" | tail -1 | awk '{print $1}') # blocks, 512B block size
    LOCAL_BOOTSECTOR=$(( LOCAL_ROOT_START - 1 )) # blocks, to set the actual bootsector
    LOCAL_DDBOOTSECTOR=$(( LOCAL_BOOTSECTOR + 256 )) # blocks, adding 256 extra to cover root filesystem
    debug 'DEBUG' "LOCAL_ROOT_START=$LOCAL_ROOT_START blocks | LOCAL_BOOTSECTOR=$LOCAL_BOOTSECTOR blocks | LOCAL_DDBOOTSECTOR=$LOCAL_DDBOOTSECTOR blocks"
    LOCAL_ROOT_START=$(( LOCAL_ROOT_START * 512 )) # bytes
    LOCAL_BOOTSECTOR=$(( LOCAL_BOOTSECTOR * 512 )) # bytes
    debug 'DEBUG' "LOCAL_ROOT_START=$LOCAL_ROOT_START bytes | LOCAL_BOOTSECTOR=$LOCAL_BOOTSECTOR bytes"
  fi

  if [ "$RESIZE2FS_RUN" == true ]; then
    if [ $FSTYPE == 'ext4' ]; then
      BLOCKSIZE=$(dumpe2fs -h "$LOCAL_DEV_ROOT_PATH" | grep -i "block size" | awk '{print $3}') # bytes
      debug 'DEBUG' "BLOCKSIZE=$BLOCKSIZE"
      LOCAL_RESIZE2FS_MIN=$(resize2fs -P "$LOCAL_DEV_ROOT_PATH" | awk '{print $7}') # blocks
      LOCAL_RESIZE2FS_MIN=$(( LOCAL_RESIZE2FS_MIN * BLOCKSIZE )) # bytes
      debug 'DEBUG' "LOCAL_RESIZE2FS_MIN=${LOCAL_RESIZE2FS_MIN} bytes"
    else
      debug 'INFO' 'Running function: get_btrfs_variables'
      get_btrfs_variables
    fi
  fi

  # Method 1, using the value of "size - available"
  LOCAL_DF_OUTPUT=( $(df / -k --sync --output=size,avail | tail -1) ) # 1k blocks, 0 is the first position in an array
  LOCAL_USED_SPACE=$(( (${LOCAL_DF_OUTPUT[0]} - ${LOCAL_DF_OUTPUT[1]}) * 1024 )) # bytes, df is in 1k blocks, 0 is the first position

  # Method 2, using "used space" straight up
  #LOCAL_DF_OUTPUT=( $(df / -k --sync --output=used | tail -1) ) # 1k blocks
  #LOCAL_USED_SPACE=$(( LOCAL_DF_OUTPUT * 1024 )) # bytes, df is in 1k blocks

  # Use resize2fs to set size if option is selected
  if [ "$RESIZE2FS_RUN" == true ]; then
    debug 'INFO' 'Setting TOTAL (space needed for files on root) to size calculated by resize2fs'
    TOTAL=$LOCAL_RESIZE2FS_MIN # bytes
  else
    debug 'INFO' 'Calculating TOTAL (space needed for files on root) by adding LOCAL_USED_SPACE and ADDED_SPACE'
    debug 'DEBUG' "LOCAL_USED_SPACE=${LOCAL_USED_SPACE} bytes | ADDED_SPACE=${ADDED_SPACE} bytes"
    TOTAL=$(( LOCAL_USED_SPACE + ADDED_SPACE )) # bytes
  fi
  debug 'DEBUG' "TOTAL=${TOTAL} bytes"

  if [ "$UPDATE" == false ] || [ "$RESIZE_RUN" == true ]; then
    TRUNCATE_TOTAL=$(( LOCAL_BOOTSECTOR + TOTAL )) # bytes
    debug 'INFO' 'Calculating .img file size by adding LOCAL_BOOTSECTOR to TOTAL'
    debug 'DEBUG' "TRUNCATE_TOTAL=${TRUNCATE_TOTAL} bytes"
  fi

  # Add 128MiB extra space if resize2fs reports bigger minimum than created
  if [ "$UPDATE" == false ] && [ "$TOTAL" -lt "$LOCAL_RESIZE2FS_MIN" ]; then
    debug 'WARNING' 'Adding WIGGLEROOM (128MiB) because manually requested ADDED_SPACE is less than resize2fs caluclated size'
    RESIZE2FS_WARNING=true
    WIGGLEROOM=134217728 # 128MiB = 134217728B, 192MiB = 201326592B
    TRUNCATE_TOTAL=$(( TRUNCATE_TOTAL + WIGGLEROOM ))
    debug 'DEBUG' "RESIZE2FS_WARNING=true | WIGGLEROOM=${WIGGLEROOM} bytes | TRUNCATE_TOTAL=${TRUNCATE_TOTAL} bytes"
  fi

return 0
}



# Function to gather btrfs information
function get_btrfs_variables() {

  if [ $RESIZE2FS_RUN == true ]; then
    debug 'INFO' 'Using btrfs fi du to calculate recommended size and adding 192MiB'
    LOCAL_RESIZE2FS_MIN=$(btrfs filesystem du -s --raw / 2>/dev/null) # bytes
    LOCAL_RESIZE2FS_MIN=$(echo "$LOCAL_RESIZE2FS_MIN" | tail -1 | awk '{print $1}')
    LOCAL_RESIZE2FS_MIN=$(( LOCAL_RESIZE2FS_MIN + 201326592 )) # 192MiB = 201326592B
    debug 'DEBUG' "LOCAL_RESIZE2FS_MIN=$LOCAL_RESIZE2FS_MIN bytes"
  fi
  debug 'DEBUG' "Running: btrfs subvolume list / | awk '{print \$9}'"
  #LOCAL_SUBVOLUMES=( $(sudo btrfs subvolume list / | awk '{print $2,$9}') )
  LOCAL_SUBVOLUMES=( $(btrfs subvolume list / | awk '{print $9}') )
  #local_subvolumes_count=$(( ${#LOCAL_SUBVOLUMES[@]} / 2 ))
  debug 'DEBUG' "LOCAL_SUBVOLUMES=$(echo ${LOCAL_SUBVOLUMES[@]})"
  if [ "$EXCLUDE_FILE" == true ]; then
    debug 'INFO' 'Filtering out volumes from exclude.txt'
    for ((i = 0; i < ${#LOCAL_SUBVOLUMES[@]}; i++)); do
      if $(echo "/${LOCAL_SUBVOLUMES[i]}" | grep -q -f "$(dirname $0)/exclude.txt"); then
        debug 'DEBUG' "Filtering out subvolume: ${LOCAL_SUBVOLUMES[i]}"
        unset LOCAL_SUBVOLUMES["$i"]
      fi
    done
    debug 'DEBUG' "After filtering, LOCAL_SUBVOLUMES=$(echo ${LOCAL_SUBVOLUMES[@]})"
  fi

return 0
}



# Function to gather image information
function get_img_variables() {

  debug 'DEBUG' "Running: ls -l $IMG_FILE | awk '{print \$5}'"
  IMG_SIZE=$(ls -l "$IMG_FILE" | awk '{print $5}')
  debug 'DEBUG' "IMG_SIZE=$IMG_SIZE bytes"

  if $(cat /etc/fstab | grep -q 'boot'); then
    debug 'INFO' 'Separate boot partition detected'
    debug 'DEBUG' "Running: cat /etc/fstab | grep '/boot' | awk '{print \$2}'"
    BOOT_PATH=$(cat /etc/fstab | grep '/boot' | awk '{print $2}')
    debug 'DEBUG' "BOOT_PATH=$BOOT_PATH"

    # ext4
    if [ "$FSTYPE" == 'ext4' ]; then
      LOCAL_BOOT_UUID=$(lsblk -o uuid "$LOCAL_DEV_BOOT_PATH" | tail -1)
      LOCAL_ROOT_UUID=$(lsblk -o uuid "$LOCAL_DEV_ROOT_PATH" | tail -1)
      # no idea why, but without this sleep, IMG_DEV_BOOT_PATH & IMG_DEV_ROOT_PATH does not get set
      sleep 1
      IMG_DEV_BOOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_BOOT_UUID" | awk '{print $1}')
      IMG_DEV_ROOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
      debug 'DEBUG' "LOCAL_BOOT_UUID=$LOCAL_BOOT_UUID | LOCAL_ROOT_UUID=$LOCAL_ROOT_UUID"
      debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"

    # btrfs (old method)
    else
      IMG_DEV_BOOT_PATH="${LOOP}p1"
      IMG_DEV_ROOT_PATH="${LOOP}p2"
      debug 'DEBUG' "BOOT_PATH=$BOOT_PATH | IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
    fi

  else
    debug 'INFO' 'No boot partition detected'
    LOCAL_ROOT_UUID=$(lsblk -o uuid "$LOCAL_DEV_ROOT_PATH" | tail -1)
    IMG_DEV_ROOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
    debug 'DEBUG' "LOCAL_ROOT_UUID=$LOCAL_ROOT_UUID | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
  fi

  # check for subvolumes on img
  if [ "$FSTYPE" == 'btrfs' ]; then
    # Check for temp directory and create if needed
    if ! [ -d "$TMP_DIR" ]; then
      echo '## Creating temp directory...'
      $SLEEPING
      debug 'INFO' 'Creating temp directory'
      debug 'DEBUG' "Running: mktemp -d -t backup-XXX"
      TMP_DIR=$(mktemp -d -t backup-XXX)
      debug 'DEBUG' "TMP_DIR=$TMP_DIR"
    fi
    $SLEEPING
    partprobe "$LOOP"
    fstab=( $(cat /etc/fstab | grep '/ ') )
    debug 'INFO' 'Mounting root to find subvolumes'
    debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "$output\n## ROOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "ROOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    $SLEEPING
    debug 'DEBUG' "Running: btrfs subvolume list $TMP_DIR | awk '{print \$9}'"
    IMG_SUBVOLUMES=( $(btrfs subvolume list "$TMP_DIR" | awk '{print $9}') )
    debug 'DEBUG' "IMG_SUBVOLUMES=$(echo ${IMG_SUBVOLUMES[@]})"
    debug 'DEBUG' "Running: umount $TMP_DIR"
    umount "$TMP_DIR"
  fi

return 0
}



# Function for shared variables
function set_img_variables() {

  if $(cat /etc/fstab | grep -q 'boot'); then
    debug 'INFO' 'Separate boot partition detected'
    debug 'DEBUG' "Running: cat /etc/fstab | grep '/boot' | awk '{print \$2}'"
    BOOT_PATH=$(cat /etc/fstab | grep '/boot' | awk '{print $2}')
    debug 'DEBUG' "BOOT_PATH=$BOOT_PATH"

    # ext4
    if [ "$FSTYPE" == 'ext4' ]; then
      LOCAL_BOOT_UUID=$(lsblk -o uuid "$LOCAL_DEV_BOOT_PATH" | tail -1)
      LOCAL_ROOT_UUID=$(lsblk -o uuid "$LOCAL_DEV_ROOT_PATH" | tail -1)
      # no idea why, but without this sleep, IMG_DEV_BOOT_PATH & IMG_DEV_ROOT_PATH does not get set
      sleep 1
      IMG_DEV_BOOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_BOOT_UUID" | awk '{print $1}')
      IMG_DEV_ROOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
      debug 'DEBUG' "LOCAL_BOOT_UUID=$LOCAL_BOOT_UUID | LOCAL_ROOT_UUID=$LOCAL_ROOT_UUID"
      debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"

    # btrfs (old method)
    else
      IMG_DEV_BOOT_PATH="${LOOP}p1"
      IMG_DEV_ROOT_PATH="${LOOP}p2"
      debug 'DEBUG' "BOOT_PATH=$BOOT_PATH | IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
    fi

  else
    debug 'INFO' 'No boot partition detected'
    LOCAL_ROOT_UUID=$(lsblk -o uuid "$LOCAL_DEV_ROOT_PATH" | tail -1)
    IMG_DEV_ROOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
    debug 'DEBUG' "LOCAL_ROOT_UUID=$LOCAL_ROOT_UUID | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
  fi

return 0
}



# Function to loop img file
function do_loop() {

  if [ "$IS_LOOPED" == false ] && [ -z "$LOOP" ]; then
    LOOP=$(losetup -f)
    debug 'DEBUG' "LOOP=$LOOP"
  fi

  echo '## Looping img file...'
  $SLEEPING
  debug 'DEBUG' "Running: losetup -P $LOOP $IMG_FILE"
  if ! output=$(losetup -P "$LOOP" "$IMG_FILE" 2>&1); then
    echo -e "$output\n## LOSETUP FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "LOSETUP FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  IS_LOOPED=true
  debug 'DEBUG' "IS_LOOPED=$IS_LOOPED"

return 0
}



# Function to mount img file
function do_mount() {

  # Check for temp directory and create if needed
  if ! [ -d "$TMP_DIR" ]; then
    echo '## Creating temp directory...'
    $SLEEPING
    debug 'INFO' 'Creating temp directory'
    debug 'DEBUG' "Running: mktemp -d -t backup-XXX"
    TMP_DIR=$(mktemp -d -t backup-XXX)
    debug 'DEBUG' "TMP_DIR=$TMP_DIR"
  fi
  $SLEEPING
  partprobe "$LOOP"

  # btrfs
  if [ "$FSTYPE" = 'btrfs' ]; then
    fstab=( $(cat /etc/fstab | grep '/ ') )
    echo "## Mounting root subvolume..."
    debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "$output\n## ROOT SUBVOLUME MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "ROOT SUBVOLUME MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    $SLEEPING

    for ((i = 0; i < ${#LOCAL_SUBVOLUMES[@]}; i++)); do
      SUBVOL_PATH="${LOCAL_SUBVOLUMES[i]}"
      if $(cat /etc/fstab | grep -q "$SUBVOL_PATH") && [[ "$SUBVOL_PATH" != '@' ]]; then
        fstab=( $(cat /etc/fstab | grep "$SUBVOL_PATH") )
        if ! [ -d "${TMP_DIR}${fstab[1]}" ]; then
          debug 'DEBUG' "Running: mkdir -p ${TMP_DIR}${fstab[1]}"
          mkdir -p "${TMP_DIR}${fstab[1]}"
        fi
        echo "## Mounting subvolume: $SUBVOL_PATH"
        debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH ${TMP_DIR}${fstab[1]}"
        if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" ${TMP_DIR}${fstab[1]} 2>&1); then
          echo -e "$output\n## SUBVOLUME MOUNT FAILED!!!"
          debug 'BREAK'
          debug 'ERROR' "SUBVOLUME MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
          exit 1
        fi

      elif [[ "$SUBVOL_PATH" != '@'* ]]; then
        if ! [ -d "${TMP_DIR}/${SUBVOL_PATH}" ]; then
          #debug 'DEBUG' "Running: mkdir -p ${TMP_DIR}/$(dirname $SUBVOL_PATH)"
          debug 'DEBUG' "Running: mkdir -p ${TMP_DIR}/${SUBVOL_PATH}"
          #mkdir -p ${TMP_DIR}/$(dirname $SUBVOL_PATH)
          mkdir -p "${TMP_DIR}/${SUBVOL_PATH}"
        fi
      fi
      $SLEEPING
    done

  # ext4
  else
    echo '## Mounting img root partition...'
    $SLEEPING
    debug 'INFO' 'Mounting root partition from loop'
    debug 'DEBUG' "Running: mount $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "$output\n## ROOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "ROOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  fi

  # Checking if boot partition exists and if true, mount boot
  if [ $(lsblk | grep -c 'boot') -ne 0 ]; then
    echo '## Mounting img boot partition...'
    $SLEEPING
    debug 'INFO' 'Separate boot partition detected, mounting boot inside root'
    if ! [ -d ${TMP_DIR}${BOOT_PATH} ]; then
      debug 'INFO' 'Boot directory did not exist'
      debug 'DEBUG' "Running: mkdir -p ${TMP_DIR}${BOOT_PATH}"
      mkdir -p ${TMP_DIR}${BOOT_PATH}
    fi
    debug 'DEBUG' "Running: mount $IMG_DEV_BOOT_PATH ${TMP_DIR}${BOOT_PATH}"
    if ! output=$(mount "$IMG_DEV_BOOT_PATH" "${TMP_DIR}${BOOT_PATH}" 2>&1); then
      echo -e "$output\n## BOOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "BOOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  fi
  return 0
}



# Function to check filesystem
function do_e2fsck() {

  if [ -n "$BOOT_PATH" ] && [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}${BOOT_PATH} " /proc/mounts; then
    debug 'INFO' 'Unmounting boot partition'
    debug 'DEBUG' "Running: umount ${TMP_DIR}${BOOT_PATH}"
    umount "${TMP_DIR}${BOOT_PATH}"
  fi

  if [ -n "$TMP_DIR" ] && grep -qs "$TMP_DIR " /proc/mounts; then
    debug 'INFO' 'Unmounting root partition'
    debug 'DEBUG' "Running: umount $TMP_DIR"
    umount "$TMP_DIR"
  fi

  if [ "$*" = 'final' ]; then
    # Final check of filesystem
    echo '## Finalizing filesystem...'
    $SLEEPING

    output=$(e2fsck -p -f -v "$IMG_DEV_ROOT_PATH" 2>&1)
    echo "$output"
    debug 'BREAK'
    debug 'DEBUG' "Running: e2fsck -p -f -v $IMG_DEV_ROOT_PATH\n$output\n------------------------------------------------------------------------------"
    $SLEEPING

    # Remounting if autoexpansion is requested
    if [ "$AUTOEXPAND" == true ]; then
      echo '## Remounting for autoexpansion...'
      debug 'INFO' 'Remounting for autoexpansion function'
      debug 'INFO' 'Running function: do_mount'
      $SLEEPING
      do_mount
    fi

  else
    echo '## Checking img filesystem...'
    $SLEEPING

    output=$(e2fsck -p -f "$IMG_DEV_ROOT_PATH" 2>&1)
    echo "$output"
    debug 'DEBUG' "Running: e2fsck -p -f $IMG_DEV_ROOT_PATH\n$output\n------------------------------------------------------------------------------"
    $SLEEPING
  fi

  return 0
}



# Function to resize image
function do_resize() {

  # Reading offset for img root partition
  debug 'INFO' 'Using fdisk to find img root partition offset'
  debug 'DEBUG' "Running: fdisk -lo start $IMG_FILE | tail -1"
  IMG_ROOT_START=$(fdisk -lo start "$IMG_FILE" | tail -1 | awk '{print $1}') # blocks, 521B block size
  debug 'DEBUG' "IMG_ROOT_START=$IMG_ROOT_START blocks"
  IMG_ROOT_START=$(( IMG_ROOT_START * 512 )) # bytes
  debug 'DEBUG' "IMG_ROOT_START=$IMG_ROOT_START bytes"

  # Converting TOTAL > TOTALK (bytes > kibibytes)
  debug 'INFO' 'Converting TOTAL > TOTALK (bytes > kibibytes)'
  TOTALK=$(( TOTAL / 1024 )) # kibibytes
  debug 'DEBUG' "TOTAL=$TOTAL bytes | TOTALK=$TOTALK kibibytes"

  # Gather information
  debug 'INFO' 'Using parted to fetch root partition number'
  debug 'DEBUG' "Running: parted -sm "$LOOP" print | tail -1 | cut -d : -f 1"
  IMG_ROOT_PARTN=$(parted -sm "$LOOP" print | tail -1 | cut -d : -f 1)
  debug 'DEBUG' "IMG_ROOT_PARTN=$IMG_ROOT_PARTN"

  # Check img filesystem
  debug 'INFO' 'Running function: do_e2fsck'
  do_e2fsck


  # expanding
  if [ "$*" = 'expand' ]; then

    echo '## Expanding img filesystem...'
    $SLEEPING

    # Removing loop for tuncate to take effect
    echo '## Removing loop...'
    $SLEEPING
    debug 'INFO' 'Removing loop for truncate to take effect'
    debug 'DEBUG' "Running: losetup -d $LOOP"
    losetup -d "$LOOP"
    IS_LOOPED=false
    debug 'DEBUG' "IS_LOOPED=$IS_LOOPED"

    echo "## Resizing image file..."
    $SLEEPING
    debug 'INFO' "Using truncate to resize img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
    debug 'DEBUG' "Running: truncate --size=$TRUNCATE_TOTAL $IMG_FILE"
    if ! output=$(truncate --size="$TRUNCATE_TOTAL" "$IMG_FILE" 2>&1); then
      echo -e "$output\n## TRUNCATE FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "TRUNCATE FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

    # Loop img file
    debug 'INFO' 'Re-looping img file to fetch new img size'
    debug 'INFO' 'Running function: do_loop'
    do_loop

    echo '## Removing partition...'
    $SLEEPING
    #debug 'INFO' 'Using sfdisk to remove root partition'
    debug 'INFO' 'Using parted to remove root partition'
    #debug 'DEBUG' "Running: sfdisk --delete -f $LOOP $IMG_ROOT_PARTN"
    debug 'DEBUG' "Running: parted -s $LOOP rm $IMG_ROOT_PARTN"
    #debug 'DEBUG' "Running: printf 'Ignore\\\n'$IMG_ROOT_PARTN | parted $LOOP rm $IMG_ROOT_PARTN ---pretend-input-tty"

    #if ! output=$(sfdisk --delete -f "$LOOP" "$IMG_ROOT_PARTN" 2>&1); then # might fail if img size is very big
    if ! output=$(parted -s "$LOOP" rm "$IMG_ROOT_PARTN" 2>&1); then # for some reason this line works here but not when creating img
    #if ! output=$(printf 'Ignore\n'$IMG_ROOT_PARTN | parted $LOOP rm $IMG_ROOT_PARTN ---pretend-input-tty 2>&1); then # raspberry pi os does not like this method, keep for memory
      #echo -e "$output\n## SFDISK FAILED!!!"
      echo -e "$output\n## PARTED FAILED!!!"
      debug 'BREAK'
      #debug 'ERROR' "SFDISK FAILED:\n$output\n------------------------------------------------------------------------------"
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

    echo '## Recreating partition...'
    $SLEEPING
    debug 'INFO' 'Using parted to recreate root partition'
    debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary ext4 $IMG_ROOT_START 100%"
    if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary ext4 "$IMG_ROOT_START" 100% 2>&1); then
      echo -e "$output\n## PARTED FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

    echo '## Resizing filesystem...'
    $SLEEPING
    debug 'INFO' 'Using resize2fs to expand filesystem'
    debug 'BREAK'
    debug 'DEBUG' "Running: resize2fs -p -f $IMG_DEV_ROOT_PATH"
    if ! output=$(resize2fs -p -f "$IMG_DEV_ROOT_PATH" 2>&1); then
      echo -e "$output\n## RESIZE2FS FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "RESIZE2FS FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "$output\n------------------------------------------------------------------------------"

    # Check img filesystem
    debug 'INFO' 'Running function: do_e2fsck'
    do_e2fsck


  # shrinking
  elif [ "$*" = 'shrink' ]; then

    echo '## Shrinking filesystem...'
    $SLEEPING
    debug 'INFO' 'Using resize2fs to shrink filesystem'
    debug 'BREAK'
    debug 'DEBUG' "Running: resize2fs -p -f $IMG_DEV_ROOT_PATH ${TOTALK}K"
    if ! output=$(resize2fs -p -f "$IMG_DEV_ROOT_PATH" "$TOTALK"K 2>&1 | tee "$LOG_TARGET"); then
      echo -e "$output\n## RESIZE2FS FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "RESIZE2FS FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "$output\n------------------------------------------------------------------------------"

    echo '## Shrinking partition...'
    $SLEEPING
    debug 'INFO' 'Using parted to shrink partition'
    debug 'BREAK'
    #debug 'DEBUG' "Running: parted -s -a none $LOOP unit B resizepart $IMG_ROOT_PARTN $TRUNCATE_TOTAL"
    debug 'DEBUG' "Running: printf 'Yes\\\n' | parted -a none $LOOP unit B resizepart $IMG_ROOT_PARTN $TRUNCATE_TOTAL ---pretend-input-tty"

    #if ! output=$(parted -s -a none "$LOOP" unit B resizepart "$IMG_ROOT_PARTN" "$TRUNCATE_TOTAL" 2>&1); then # retry this after -f got removed, before = does not work, still asking for user confirmation even though --script and -f (automatically answer "fix" to exceptions in script mode) is used
    if ! output=$(printf 'Yes\n' | parted -a none "$LOOP" unit B resizepart "$IMG_ROOT_PARTN" "$TRUNCATE_TOTAL" ---pretend-input-tty 2>&1); then
      echo -e "$output\n## PARTED FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "$output\n------------------------------------------------------------------------------"

    echo '## Shrinking img file...'
    $SLEEPING
    debug 'INFO' "Using truncate to shrink img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
    debug 'DEBUG' "Running: truncate --size=$TRUNCATE_TOTAL $IMG_FILE"
    if ! output=$(truncate --size="$TRUNCATE_TOTAL" "$IMG_FILE" 2>&1); then
      echo -e "$output\n## TRUNCATE FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "TRUNCATE FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

    # Final check of img filesystem
    debug 'INFO' 'Finalizing filesystem'
    debug 'DEBUG' "Running do_e2fsck 'final'"
    do_e2fsck 'final'

  fi
  return 0
}



# Function to rsync to img file
function do_rsync() {

  echo '## Backing up files...'
  $SLEEPING
  IMG_PATH=$(dirname "$IMG_FILE")
  debug 'INFO' 'Creating temporary file to store rsync output'
  debug 'DEBUG' "Backing up to ${IMG_PATH}${IMG_FILE}"
  debug 'DEBUG' 'Running: mktemp -t rsync-XXX'
  tmp_file=$(mktemp -t rsync-XXX)
  debug 'DEBUG' "tmp_file=$tmp_file"

  if [ "$EXCLUDE_FILE" == true ]; then
    debug 'DEBUG' "Running: rsync -ahvHAX --exclude-from=$(dirname $0)/exclude.txt --exclude={${IMG_PATH}/*,${TMP_DIR},${tmp_file}} --info=progress2 --stats "$RSYNC_DELETE" --force --partial --delete-excluded / $TMP_DIR"
    rsync -ahvHAX --exclude-from=$(dirname "$0")/exclude.txt --exclude={${IMG_PATH}/*,${TMP_DIR},${tmp_file}} --info=progress2 --stats "$RSYNC_DELETE" --force --partial --delete-excluded / "$TMP_DIR" 2>&1 | tee "$LOG_TARGET"  > "$tmp_file"
    # Get the exit status of rsync from PIPESTATUS
    if [ "${PIPESTATUS[0]}" -ne 0 ]; then #code 23
      output=$(tail -16 "$tmp_file")
      echo -e "$output\n## RSYNC FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "RSYNC FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  else
    debug 'DEBUG' "Running: rsync -ahvHAX --exclude={/lost+found,/proc/*,/sys/*,/dev/*,/tmp/*,/run/*,/mnt/*,/media/*,${IMG_PATH}/*} --info=progress2 --stats "$RSYNC_DELETE" --force --partial --delete-excluded / $TMP_DIR"
    rsync -ahvHAX --exclude={/lost+found,/proc/*,/sys/*,/dev/*,/tmp/*,/run/*,/mnt/*,/media/*,${IMG_PATH}/*} --info=progress2 --stats "$RSYNC_DELETE" --force --partial --delete-excluded / "$TMP_DIR" 2>&1 | tee "$LOG_TARGET" > "$tmp_file"
    if [ "${PIPESTATUS[0]}" -ne 0 ]; then #code 23
      output=$(tail -16 "$tmp_file")
      echo -e "$output\n## RSYNC FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "RSYNC FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  fi
  echo '## Rsync done...'
  echo '## Please stand by...'
  output=$(tail -16 "$tmp_file")
  debug 'BREAK'
  debug 'DEBUG' "Rsync report:\n$output\n------------------------------------------------------------------------------"
  debug 'INFO' 'Rsync done'
  sleep 4
  return 0
}



# Function to create a backup img file
function make_img() {

  debug 'INFO' 'Running function: get_dev_variables'
  get_dev_variables

  # Display information
  if [ "$PROMPTS" == true ]; then
    echo ''
    echo '##############################################################################'
    echo "# A backup will be created at $IMG_FILE"
    if [ "$FSTYPE" == 'ext4' ]; then
      echo '# ext4 filesystem detected on root'
    else
      echo '# btrfs filesystem detected on root'
      echo "# ${#LOCAL_SUBVOLUMES[@]} btrfs volumes will be included"
      echo "# btrfs volumes: ${LOCAL_SUBVOLUMES[@]}"
    fi
    echo '# ----------------------------------------------------------------------------'
    echo "# Write to logfile: $DEBUG"
    echo "# Zoom speed requested: $ZOOM"
    echo "# Autsize img root partition: $RESIZE2FS_RUN"
    echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "# Use exclude.txt: $EXCLUDE_FILE"
    echo "# Bootsector size: $(( LOCAL_BOOTSECTOR / 1024 / 1024 ))MiB"
    echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
    if [ "$RESIZE2FS_RUN" == true ]; then
      echo "# Auto calculated size (root partition): $(( LOCAL_RESIZE2FS_MIN / 1024 / 1024 ))MiB"
      echo "# Total img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
    else
      echo "# Manually added space: $(( ADDED_SPACE / 1024 / 1024 ))MiB"
      echo "# Total img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB with $(( ADDED_SPACE / 1024 / 1024 ))MiB extra space included."
      if [ "$RESIZE2FS_WARNING" == true ]; then
        echo '# ----------------------------------------------------------------------------'
        echo "# WARNING!!! Manually added space is smaller than calculated recommended minimum"
        echo "# This does NOT mean the backup WILL fail, but CAN fail due to lack of space"
        echo "# Consider using the -a option or manually adding more space"
        echo "# Requested root size: $(( TOTAL / 1024 / 1024 ))MiB"
        echo "# Calculated recommended minimum: $(( LOCAL_RESIZE2FS_MIN / 1024 / 1024 ))MiB"
      fi
    fi
    echo '##############################################################################'

    # Confirm with user input
    read -p "Do you want to continue? [y/n] " -n 1 -r
    debug 'INFO' 'Do you want to continue? [y/n]'
    if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
      debug 'WARNING' 'Aborted by user, exit 4'
      echo ''
      echo '## Aborting...'
      exit 4
    fi
    echo ''
    debug 'INFO' 'Y or y pressed to confirm'
    debug 'BREAK'

    if test -f "$IMG_FILE"; then
      debug 'WARNING' "$IMG_FILE ALREADY EXISTS!"
      echo 'WARNING!!! WARNING!!! WARNING!!!'
      echo "$IMG_FILE"
      echo 'FILE ALREADY EXISTS!!!'
      read -p "Do you want to overwrite? [y/n] " -n 1 -r
      debug 'WARNING' 'Do you want to overwrite? [y/n]'
      if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
        debug 'WARNING' 'Aborted by user, exit 4'
        echo ''
        echo '## Aborting...'
        exit 4
      fi
      echo ''
      debug 'WARNING' 'Overwrite confirmed by user'
    fi

  else

    debug 'INFO' '-y selected by user. prompts are disabled'
    echo '##############################################################################'
    echo '# DISABLE PROMPTS SELECTED (-y), NO WARNINGS ABOUT DELETION!!!'
    echo "# A backup will be created at $IMG_FILE"
    if [ "$FSTYPE" == 'ext4' ]; then
      echo '# ext4 filesystem detected on root'
    else
      echo '# btrfs filesystem detected on root'
      echo "# ${#LOCAL_SUBVOLUMES[@]} btrfs volumes will be included"
      echo "# btrfs volumes: ${LOCAL_SUBVOLUMES[@]}"
    fi
    echo '# ----------------------------------------------------------------------------'
    echo "# Write to logfile: $DEBUG"
    echo "# Zoom speed requested: $ZOOM"
    echo "# Autosize img root partition: $RESIZE2FS_RUN"
    echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "# Use exclude.txt: $EXCLUDE_FILE"
    echo "# Bootsector size: $(( LOCAL_BOOTSECTOR / 1024 / 1024 ))MiB"
    echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
    if [ "$RESIZE2FS_RUN" == true ]; then
      echo "# Auto calculated size (root partition): $(( LOCAL_RESIZE2FS_MIN / 1024 / 1024 ))MiB"
      echo "# Total img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
    else
      echo "# Manually added space: $(( ADDED_SPACE / 1024 / 1024 ))MiB"
      echo "# Total img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB with $(( ADDED_SPACE / 1024 / 1024 ))MiB extra space included."
      if [ "$RESIZE2FS_WARNING" == true ]; then
        echo '# ----------------------------------------------------------------------------'
        echo "# WARNING!!! Manually added space is smaller than calculated recommended minimum"
        echo "# This does NOT mean the backup WILL fail, but CAN fail due to lack of space"
        echo "# Consider using the -a option or manually adding more space"
        echo "# Requested root size: $(( TOTAL / 1024 / 1024 ))MiB"
        echo "# Calculated recommended minimum: $(( LOCAL_RESIZE2FS_MIN / 1024 / 1024 ))MiB"
      fi
    fi
    if [ "$ZOOM" == false ]; then
      echo '# PRESS CTRL+C WITHIN 5s TO CANCEL!'
      echo '##############################################################################'
      sleep 6
      debug 'INFO' '6 seconds passed, user did not stop operation'
      debug 'BREAK'
    fi
  fi

  # Delete existing file if user validation above passed
  if [ -f "$IMG_FILE" ]; then
    debug 'WARNING' "Removing: $IMG_FILE"
    echo '## Removing old img file...'
    rm "$IMG_FILE"
    $SLEEPING
  fi

  # Create and dd bootsector
  echo '## Creating bootsector...'
  $SLEEPING
  debug 'INFO' 'Using dd to create bootsector'
  if ! output=$(dd bs=512 count=$LOCAL_DDBOOTSECTOR if="$LOCAL_DEV_PATH" of="$IMG_FILE" conv=noerror,sync status=progress 2>&1 | tee "$LOG_TARGET"); then
    echo -e "$output\n## DD TO LOCAL_BOOTSECTOR FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "DD TO LOCAL_BOOTSECTOR FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  output=$(echo "$output" | tail -3 )
  debug 'BREAK'
  debug 'DEBUG' "Running: dd bs=512 count=$LOCAL_DDBOOTSECTOR if=$LOCAL_DEV_PATH of=$IMG_FILE conv=noerror,sync status=progress\n$output\n------------------------------------------------------------------------------"
  $SLEEPING

  # Truncate file to correct size
  echo "## Resizing img file..."
  $SLEEPING
  debug 'INFO' "Using truncate to resize img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
  debug 'DEBUG' "Running: truncate --size=$TRUNCATE_TOTAL $IMG_FILE"
  if ! output=$(truncate --size="$TRUNCATE_TOTAL" "$IMG_FILE" 2>&1); then
    echo -e "$output\n## TRUNCATE FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "TRUNCATE FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  $SLEEPING

  # Loop img file
  debug 'DEBUG' 'Running function: do_loop'
  do_loop

  # set img variables
  debug 'INFO' 'Running function: set_img_variables'
  set_img_variables

  # Remove partition
  echo '## Removing root partition...'
  $SLEEPING

  # GPT
  if [ $PARTITION_TABLE == 'gpt' ]; then
    echo '## GPT partition table detected, sgdisk is needed, checking if installed...'
    $SLEEPING
    if [[ ! -f $(which sgdisk 2>&1) ]]; then
      echo '## sgdisk is NOT installed...'
      debug 'INFO' 'sgdisk not available on system'
      read -p "Do you want to try to install gdisk? [y/n] " -n 1 -r
      debug 'INFO' 'Do you want to try to install gdisk? [y/n]'
      if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
        debug 'WARNING' 'Aborted by user, exit 5'
        echo ''
        echo '## Aborting...'
        exit 5
      fi
      echo ''
      debug 'INFO' 'Y or y pressed to confirm'
      if [[ -f $(which apt 2>&1) ]]; then
        echo '## apt found, trying to install gdisk...'
        read -p "Do you want to use apt to install gdisk? [y/n] " -n 1 -r
        debug 'INFO' 'Do you want to use apt to install gdisk? [y/n]'
        if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
          debug 'WARNING' 'Aborted by user, exit 5'
          echo ''
          echo '## Aborting...'
          exit 5
        fi
        echo ''
        debug 'INFO' 'Y or y pressed to confirm'
        debug 'DEBUG' 'Running: apt update -y && apt upgrade -y && apt install gdisk -y'
        $SLEEPING
        apt update -y && apt upgrade -y && apt install gdisk -y
        $SLEEPING
      elif [[ -f $(which pacman 2>&1) ]]; then
        echo '## pacman found, trying to install gdisk...'
        read -p "Do you want to use pacman to install gptfdisk? (will do -Syu first) [y/n] " -n 1 -r
        debug 'INFO' 'Do you want to use apt to install gptfdisk? (will do -Syu first) [y/n]'
        if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
          debug 'WARNING' 'Aborted by user, exit 5'
          echo ''
          echo '## Aborting...'
          exit 5
        fi
        echo ''
        debug 'INFO' 'Y or y pressed to confirm'
        debug 'DEBUG' 'Running: pacman -Syu && pacman -S gptfdisk'
        $SLEEPING
        pacman -Syu && pacman -S gptfdisk
        $SLEEPING
      else
        echo '## Did not manage to install gdisk, please install gdisk and retry script...'
        debug 'ERROR' 'Did not succeed in installing gdisk, aborting exit 1'
        echo '## Aborting...'
        exit 1
      fi
      echo '## gdisk installed successfully, resuming backup...'
      debug 'INFO' 'gdisk installed successfully'
      $SLEEPING

    else
      echo '## sgdisk is available, resuming backup...'
      debug 'INFO' 'sgdisk is available on system'
      $SLEEPING
    fi

    debug 'INFO' 'Using sgdisk to remove root partition'
    debug 'DEBUG' "Running: sgdisk $LOOP -d $LOCAL_ROOT_PARTN"
    if ! output=$(sgdisk "$LOOP" -d "$LOCAL_ROOT_PARTN" 2>&1); then
      echo -e "$output\n## SGDISK FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "SGDISK FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

  else

    # MBR
    debug 'INFO' 'Using sfdisk to remove root partition'
    #debug 'INFO' 'Using parted to remove root partition'
    debug 'DEBUG' "Running: sfdisk --delete -f $LOOP $LOCAL_ROOT_PARTN"
    #debug 'DEBUG' "Running: parted -s $LOOP rm $LOCAL_ROOT_PARTN"
    #debug 'DEBUG' "Running: printf 'Ignore\\\n'$LOCAL_ROOT_PARTN | parted $LOOP rm $LOCAL_ROOT_PARTN ---pretend-input-tty"

    if ! output=$(sfdisk --delete -f "$LOOP" "$LOCAL_ROOT_PARTN" 2>&1); then # might fail if img size is very big
    #if ! output=$(parted -s "$LOOP" rm "$LOCAL_ROOT_PARTN" 2>&1); then # retry this after -f got removed, before = does not work, still asking for user confirmation even though --script and -f (automatically answer "fix" to exceptions in script mode) is used. faults with: "Error: Can't have a partition outside the disk!". for some reason this line works in the resizing function
    #if ! output=$(printf 'Ignore\n'$LOCAL_ROOT_PARTN | parted $LOOP rm $LOCAL_ROOT_PARTN ---pretend-input-tty 2>&1); then # raspberry pi os does not like this method, keep for memory
      echo -e "$output\n## SFDISK FAILED!!!"
      #echo -e "$output\n## PARTED FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "SFDISK FAILED:\n$output\n------------------------------------------------------------------------------"
      #debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  fi
  $SLEEPING

  # Recreate partition
  echo '## Recreating root partition...'
  $SLEEPING
  debug 'INFO' 'Using parted to recreate root partition'

  # ext4
  if [ $FSTYPE == 'ext4' ]; then
    debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary ext4 $LOCAL_ROOT_START 100%"
    if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary ext4 "$LOCAL_ROOT_START" 100% 2>&1); then
      echo -e "$output\n## PARTED FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

  # btrfs
  else
    debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary btrfs $LOCAL_ROOT_START 100%"
    if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary btrfs "$LOCAL_ROOT_START" 100% 2>&1); then
      echo -e "$output\n## PARTED FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  fi
  $SLEEPING

  # Format filesystem
  echo '## Formatting filesystem...'
  $SLEEPING
  LABEL=$(lsblk -o label "$LOCAL_DEV_ROOT_PATH" | tail -1)
  UUID=$(lsblk -o uuid "$LOCAL_DEV_ROOT_PATH" | tail -1)
  debug 'DEBUG' "LABEL=$LABEL | UUID=$UUID"

  # ext4
  if [ $FSTYPE = 'ext4' ]; then
    debug 'INFO' 'Using mkfs.ext4 to format root filesystem'
    if ! output=$(mkfs.ext4 "$IMG_DEV_ROOT_PATH" -U "$UUID" -L "$LABEL" -v 2>&1 | tee "$LOG_TARGET" ); then
      echo -e "$output\n## MKFS.EXT4 FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "MKFS.EXT4 FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'BREAK'
    debug 'DEBUG' "Running: mkfs.ext4 $IMG_DEV_ROOT_PATH -U $UUID -L $LABEL -v\n$output\n------------------------------------------------------------------------------"
    $SLEEPING

    debug 'INFO' 'Running function: do_e2fsck'
    do_e2fsck

    debug 'INFO' 'Running function: do_mount'
    do_mount

  # btrfs
  else
    debug 'INFO' 'Using mkfs.btrfs to format root filesystem'
    partprobe "$LOOP"
    if ! output=$(mkfs.btrfs -m single -L "$LABEL" -f -v "$IMG_DEV_ROOT_PATH" 2>&1 | tee "$LOG_TARGET" ); then # btrfs does NOT like having the same uuid on 2 filesystems at the same time
      echo -e "$output\n## MKFS.BTRFS FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "MKFS.BTRFS FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'BREAK'
    debug 'DEBUG' "Running: mkfs.btrfs -m single -L $LABEL -f -v $IMG_DEV_ROOT_PATH\n$output\n------------------------------------------------------------------------------"
    $SLEEPING

    # Check for temp directory and create if needed
    if ! [ -d "$TMP_DIR" ]; then
      echo '## Creating temp directory...'
      $SLEEPING
      debug 'INFO' 'Creating temp directory'
      debug 'DEBUG' "Running: mktemp -d -t backup-XXX"
      TMP_DIR=$(mktemp -d -t backup-XXX)
      debug 'DEBUG' "TMP_DIR=$TMP_DIR"
    fi

    echo '## Creating btrfs subvolumes...'
    debug 'INFO' 'Creating btrfs subvolumes'
    debug 'DEBUG' "Running: mount -o compress=zstd $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount -o noatime,compress=zstd "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "$output\n## ROOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "ROOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    $SLEEPING

    # Create top subvolumes, ${#LOCAL_SUBVOLUMES[@]} gives count
    for ((i = 0; i < ${#LOCAL_SUBVOLUMES[@]}; i++)); do
      SUBVOL_PATH="${LOCAL_SUBVOLUMES[i]}"
      if [[ "$SUBVOL_PATH" == '@'* ]]; then
        echo "## Creating subvolume: $SUBVOL_PATH"
        debug 'DEBUG' "Running: btrfs subvolume create ${TMP_DIR}/${SUBVOL_PATH}"
        if ! output=$(btrfs subvolume create "$TMP_DIR"/"$SUBVOL_PATH" 2>&1); then
          echo -e "$output\n## CREATE SUBVOLUME FAILED!!!"
          debug 'BREAK'
          debug 'ERROR' "CREATE SUBVOLUME FAILED:\n$output\n------------------------------------------------------------------------------"
          exit 1
        fi
      fi
      $SLEEPING
    done

    echo '## Mounting root...'
    debug 'INFO' 'Unmounting btrfs filesystem & mounting root subvolume'
    debug 'DEBUG' "Running: umount $TMP_DIR"
    umount "$TMP_DIR"
    $SLEEPING
    partprobe "$LOOP"
    #fstab=( $(cat /etc/fstab | grep "${LOCAL_SUBVOLUMES[0]}") )
    fstab=( $(cat /etc/fstab | grep '/ ') )
    debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "$output\n## ROOT SUBVOLUME MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "ROOT SUBVOLUME MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    $SLEEPING

    # Create nested volumes/snapshots
    debug 'INFO' 'Creating nested volumes/snapshots'
    for ((i = 0; i < ${#LOCAL_SUBVOLUMES[@]}; i++)); do
      SUBVOL_PATH="${LOCAL_SUBVOLUMES[i]}"
      if [[ "$SUBVOL_PATH" != '@'* ]]; then
        debug 'DEBUG' "Running: mkdir -p $TMP_DIR/$(dirname $SUBVOL_PATH)"
        mkdir -p $TMP_DIR/$(dirname $SUBVOL_PATH)

        echo "## Creating volume: $SUBVOL_PATH"
        debug 'DEBUG' "Running: btrfs subvolume create ${TMP_DIR}/${SUBVOL_PATH}"
        if ! output=$(btrfs subvolume create "$TMP_DIR"/"$SUBVOL_PATH" 2>&1); then
          echo -e "$output\n## CREATE VOLUME FAILED!!!"
          debug 'BREAK'
          debug 'ERROR' "CREATE VOLUME FAILED:\n$output\n------------------------------------------------------------------------------"
          exit 1
        fi
      fi
      $SLEEPING
    done

    echo '## Mounting img btrfs volumes...'
    debug 'INFO' 'Mounting volumes'
    $SLEEPING
    partprobe "$LOOP"

    for ((i = 0; i < ${#LOCAL_SUBVOLUMES[@]}; i++)); do
      SUBVOL_PATH="${LOCAL_SUBVOLUMES[i]}"
      if $(cat /etc/fstab | grep -q "$SUBVOL_PATH") && [[ "$SUBVOL_PATH" != '@' ]]; then
        fstab=( $(cat /etc/fstab | grep "$SUBVOL_PATH") )
        debug 'DEBUG' "Running: mkdir -p ${TMP_DIR}${fstab[1]}"
        mkdir -p ${TMP_DIR}${fstab[1]}
        echo "## Mounting subvolume: $SUBVOL_PATH"
        debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH ${TMP_DIR}${fstab[1]}"
        if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" ${TMP_DIR}${fstab[1]} 2>&1); then
          echo -e "$output\n## VOLUME MOUNT FAILED!!!"
          debug 'BREAK'
          debug 'ERROR' "VOLUME MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
          exit 1
        fi
      fi
      $SLEEPING
    done

    echo '## Mounting boot...'
    debug 'DEBUG' "Running: mount $IMG_DEV_BOOT_PATH ${TMP_DIR}${BOOT_PATH}"
    mkdir -p ${TMP_DIR}${BOOT_PATH}
    if ! output=$(mount "$IMG_DEV_BOOT_PATH" "${TMP_DIR}${BOOT_PATH}" 2>&1); then
      echo -e "$output\n## BOOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "BOOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    $SLEEPING
  fi

  # Copy files
  debug 'INFO' 'Backing up files'
  debug 'INFO' 'Running function: do_rsync'
  do_rsync

  if [ $FSTYPE == 'ext4' ]; then
    # Final check of created img file
    debug 'INFO' "Running do_e2fsck 'final'"
    do_e2fsck 'final'
  fi

  return 0
}



# Function to update existing img file
function do_backup() {

  # Making sure img file exists
  if ! [ -f "$IMG_FILE" ]; then
    echo "## ERROR. $IMG_FILE does not exist!"
    debug 'ERROR' "$IMG_FILE does not exist, exit 1"
    exit 1
  fi

  debug 'INFO' 'Running function: get_dev_variables'
  # get_btrfs_variables is run within get_dev_variables
  get_dev_variables

  debug 'INFO' 'Running function: do_loop'
  do_loop

  debug 'INFO' 'Running function: get_img_variables'
  get_img_variables

#   if [ "$RESIZE2FS_RUN" == true ] || [ "$ADDED_SPACE" -ne 0 ]; then
#     debug 'INFO' 'Running function: get_dev_variables'
#     # get_btrfs_variables is run within get_dev_variables
#     get_dev_variables
#   elif [ "$FSTYPE" == 'btrfs' ] && [ "$RESIZE2FS_RUN" == false ] && [ "$ADDED_SPACE" -eq 0 ]; then
#     debug 'INFO' 'Running function: get_btrfs_variables'
#     get_btrfs_variables
#   fi

  # Checking if resizing should be performed
  if [ "$RESIZE2FS_RUN" == true ]; then
    debug 'DEBUG' "Running: fdisk --bytes -lo device,size "$LOOP" | grep "$IMG_DEV_ROOT_PATH" | awk '{print \$2}'"
    IMG_ROOT_SIZE=$(fdisk --bytes -lo device,size "$LOOP" | grep "$IMG_DEV_ROOT_PATH" | awk '{print $2}' )
    diff=$(( ( LOCAL_RESIZE2FS_MIN - IMG_ROOT_SIZE ) / 1024 / 1024 ))
    debug 'DEBUG' "IMG_ROOT_SIZE=$IMG_ROOT_SIZE bytes | LOCAL_RESIZE2FS_MIN=$LOCAL_RESIZE2FS_MIN bytes | diff=${diff}MiB"

    if [ "$IMG_ROOT_SIZE" -lt "$LOCAL_RESIZE2FS_MIN" ] && (( LOCAL_RESIZE2FS_MIN - IMG_ROOT_SIZE >= 268435456 )); then # 256MiB in bytes
      DIFFERENCE="$diff MiB, Expanding img filesystem"
    elif [ "$IMG_ROOT_SIZE" -gt "$LOCAL_RESIZE2FS_MIN" ] && (( IMG_ROOT_SIZE - LOCAL_RESIZE2FS_MIN >= 536870912 )); then # 512MiB in bytes
      DIFFERENCE="$diff MiB, Shrinking img filesystem"
    else
      if [ "$diff" != -* ]; then
        DIFFERENCE="Too small ($diff MiB), not expanding filesystem"
      else
        DIFFERENCE="Too small ($diff MiB), not shrinking filesystem"
      fi
    fi
  elif [ "$ADDED_SPACE" -ne 0 ]; then
    debug 'INFO' 'Manually added space provided by user, calculating img size (TRUNCATE_TOTAL) by adding ADDED_SPACE to IMG_SIZE'
    TRUNCATE_TOTAL=$(( ADDED_SPACE + IMG_SIZE ))
    debug 'DEBUG' "TRUNCATE_TOTAL=$TRUNCATE_TOTAL"
  fi

  # Display information
  if [ "$PROMPTS" == true ]; then
    echo '##############################################################################'
    echo "# Updating $IMG_FILE"
    if [ "$FSTYPE" == 'ext4' ]; then
      echo '# ext4 filesystem detected on root'
    else
      echo '# btrfs filesystem detected on root'
      echo "# ${#LOCAL_SUBVOLUMES[@]} btrfs volumes will be included"
      echo "# btrfs volumes: ${LOCAL_SUBVOLUMES[@]}"
    fi
    echo '# ----------------------------------------------------------------------------'
    echo "# Write to logfile: $DEBUG"
    echo "# Zoom speed requested: $ZOOM"
    echo "# Autoresize img root partition: $RESIZE2FS_RUN"
    echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "# Use exclude.txt: $EXCLUDE_FILE"
    if [ "$RESIZE2FS_RUN" == true ]; then
      echo "# Bootsector size: $(( LOCAL_BOOTSECTOR / 1024 / 1024 ))MiB"
      echo "# Auto calculated size (root partition): $(( LOCAL_RESIZE2FS_MIN / 1024 / 1024 ))MiB"
      echo "# Old img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
      echo "# New img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
      echo "# Difference: $DIFFERENCE"
    elif [ "$ADDED_SPACE" -ne 0 ]; then
      echo "# Bootsector size: $(( LOCAL_BOOTSECTOR / 1024 / 1024 ))MiB"
      echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
      echo "# Old img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
      echo "# New img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
      echo "# Difference: $(( ADDED_SPACE / 1024 / 1024 ))MiB"
    else
      echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
      echo "# Total img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
    fi
    echo '##############################################################################'

    # Confirm with user input
    read -p "Do you want to continue? [y/n] " -n 1 -r
    debug 'INFO' 'Do you want to continue? [y/n]'
    if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
      debug 'WARNING' 'Aborted by user, exit 4'
      echo ''
      echo 'Aborting...'
      exit 4
    fi
    echo ''
    debug 'INFO' 'Y or y pressed to confirm'
    debug 'BREAK'

  else

    echo '##############################################################################'
    echo '# DISABLE PROMPTS SELECTED'
    echo "# Updating $IMG_FILE"
    if [ "$FSTYPE" == 'ext4' ]; then
      echo '# ext4 filesystem detected on root'
    else
      echo '# btrfs filesystem detected on root'
      echo "# ${#LOCAL_SUBVOLUMES[@]} btrfs volumes will be included"
      echo "# btrfs volumes: ${LOCAL_SUBVOLUMES[@]}"
    fi
    echo '# ----------------------------------------------------------------------------'
    echo "# Write to logfile: $DEBUG"
    echo "# Zoom speed requested: $ZOOM"
    echo "# Autoresize img root partition: $RESIZE2FS_RUN"
    echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "# Use exclude.txt: $EXCLUDE_FILE"
    if [ "$RESIZE2FS_RUN" == true ]; then
      echo "# Bootsector size: $(( LOCAL_BOOTSECTOR / 1024 / 1024 ))MiB"
      echo "# Auto calculated size (root partition): $(( LOCAL_RESIZE2FS_MIN / 1024 / 1024 ))MiB"
      echo "# Old img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
      echo "# New img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
      echo "# Difference: $DIFFERENCE"
    elif [ "$ADDED_SPACE" -ne 0 ]; then
      echo "# Bootsector size: $(( LOCAL_BOOTSECTOR / 1024 / 1024 ))MiB"
      echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
      echo "# Old img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
      echo "# New img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
      echo "# Difference: $(( ADDED_SPACE / 1024 / 1024 ))MiB"
    else
      echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
      echo "# Total img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
    fi
    if [ "$ZOOM" == false ]; then
      echo '# PRESS CTRL+C WITHIN 5s TO CANCEL!'
      echo '##############################################################################'
      sleep 6
      debug 'INFO' '6 seconds passed, user did not stop operation'
      debug 'BREAK'
    fi
  fi

  # Checking if resizing should be performed
  if [ "$RESIZE2FS_RUN" == true ]; then
    if [ "$IMG_ROOT_SIZE" -lt "$LOCAL_RESIZE2FS_MIN" ] && (( LOCAL_RESIZE2FS_MIN - IMG_ROOT_SIZE >= 268435456 )); then # 256MiB in bytes
      debug 'INFO' 'Img root partition size is smaller than auto calculated size'
      debug 'DEBUG' "Difference=$diff MiB"
      debug 'INFO' "Running function: do_resize 'expand'"
      do_resize 'expand'

    elif [ "$IMG_ROOT_SIZE" -gt "$LOCAL_RESIZE2FS_MIN" ] && (( IMG_ROOT_SIZE - LOCAL_RESIZE2FS_MIN >= 536870912 )); then # 512MiB in bytes
      debug 'INFO' 'Img root partition size is bigger than auto calculated size'
      debug 'DEBUG' "diff=${diff}MiB"

      # Mount img file
      debug 'INFO' 'Running function: do_mount'
      do_mount

      # Copy files
      debug 'INFO' 'Backing up files'
      debug 'INFO' 'Running function: do_rsync'
      do_rsync

      # Shrink img file
      debug 'INFO' 'Shrinking img filesystem'
      debug 'INFO' "Running function: do_resize 'shrink'"
      do_resize 'shrink'
      return 0

    else
      debug 'INFO' 'Img root partition is <=256MiB smaller or <=512MiB bigger compared to auto calculated size, not resizing'
      $SLEEPING
    fi
  fi

  # Expand img file if ADDED_SPACE not 0
  if [ "$ADDED_SPACE" -ne 0 ]; then
    debug 'INFO' "Running function: do_resize 'expand'"
    do_resize 'expand'
  fi

  # Mount img file
  debug 'INFO' 'Running function: do_mount'
  do_mount

  # Copy files
  debug 'INFO' 'Backing up files'
  debug 'INFO' 'Running function: do_rsync'
  do_rsync

  if [ $FSTYPE == 'ext4' ]; then
    # Final check of created img file
    debug 'INFO' "Running do_e2fsck 'final'"
    do_e2fsck 'final'
  fi

  return 0
}



# Enabling autoexpansion for Manjaro
function autoexpansion_manjaro() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.target.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi

  # Creating autoexpansion systemd unit file expand-fs.service
  debug 'DEBUG' 'Systemd unit expand-fs.service does not exist, creating it'
  cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/usr/bin/resize-fs || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /etc/systemd/system/expand-fs.service && /usr/bin/reboot -f || exit 0"

[Install]
WantedBy=basic.target
EOF

  if ! [ -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi

  echo '## Manjaro filesystem autoresizing at boot...'
  debug 'INFO' 'Manjaro filesystem autoresizing at boot'
  $SLEEPING
  return 0
}



# Enabling autoexpansion for Armbian
function autoexpansion_armbian() {
  if ! test -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service"; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /lib/systemd/system/armbian-resize-filesystem.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service"
    ln -s /lib/systemd/system/armbian-resize-filesystem.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service
  fi
  echo '## Armbian filesystem autoresizing at boot...'
  debug 'INFO' 'Armbian filesystem autoresizing at boot'
  $SLEEPING
  return 0
}



# Enabling autoexpansion for Raspberry pi
function autoexpansion_rpi() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.target.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi

  # Creating autoexpansion systemd unit file expand-fs.service
  debug 'DEBUG' 'Creating systemd unit expand-fs.service'
  cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/expand-fs.sh || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /expand-fs.sh && /usr/bin/rm /etc/systemd/system/expand-fs.service && /usr/sbin/reboot -f || exit 0"

[Install]
WantedBy=basic.target
EOF

  if ! [ -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi

  # Creating script for autoexpansion
  debug 'DEBUG' "Creating expansion script ${TMP_DIR}/expand-fs.sh"
  cat << EOF2 > "${TMP_DIR}/expand-fs.sh"
#!/usr/bin/bash
LOCAL_DEV_PTUUID=\$(lsblk -lpo mountpoint,ptuuid | grep '/ ' | awk '{print \$2}')
LOCAL_DEV_PATH=\$(lsblk -lpo ptuuid,type,path | grep "\$LOCAL_DEV_PTUUID" | grep 'disk' | awk '{print \$3}')
LOCAL_ROOT_PARTN=\$(parted -sm "\$LOCAL_DEV_PATH" print | tail -1 | cut -d : -f 1)
LOCAL_DEV_ROOT_PATH=\$(lsblk -lpo mountpoint,path | grep '/ ' | awk '{print \$2}')
LOCAL_ROOT_START=\$(fdisk -lo start "\$LOCAL_DEV_PATH" | tail -1 | awk '{print \$1}') # blocks, 512B block size
LOCAL_ROOT_START=\$(( LOCAL_ROOT_START * 512 )) # bytes

sfdisk --delete -f "\$LOCAL_DEV_PATH" "\$LOCAL_ROOT_PARTN"
parted -s -a none "\$LOCAL_DEV_PATH" unit B mkpart primary ext4 "\$LOCAL_ROOT_START" 100%
resize2fs -f "\$LOCAL_DEV_ROOT_PATH"
sync
exit 0
EOF2

  debug 'DEBUG' 'Making /expand-fs.sh executable'
  chmod +x ${TMP_DIR}/expand-fs.sh

  echo '## Raspberry pi filesystem autoresizing at boot...'
  debug 'INFO' 'Raspberry pi filesystem autoresizing at boot'
  $SLEEPING
  return 0
}



# Enabling autoexpansion for ArchLinuxArm
function autoexpansion_arch() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.target.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi

  # Creating autoexpansion systemd unit file expand-fs.service
  debug 'DEBUG' 'Creating systemd unit expand-fs.service'
  cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/expand-fs.sh || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /expand-fs.sh && /usr/bin/rm /etc/systemd/system/expand-fs.service && /usr/bin/reboot -f || exit 0"

[Install]
WantedBy=basic.target
EOF

  if ! [ -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi

  # Creating script for autoexpansion
  debug 'DEBUG' 'Creating expansion script ${TMP_DIR}/expand-fs.sh'
  cat << EOF2 > "${TMP_DIR}/expand-fs.sh"
#!/usr/bin/bash
LOCAL_DEV_PTUUID=\$(lsblk -lpo mountpoint,ptuuid | grep '/ ' | awk '{print \$2}')
LOCAL_DEV_PATH=\$(lsblk -lpo ptuuid,type,path | grep "\$LOCAL_DEV_PTUUID" | grep 'disk' | awk '{print \$3}')
LOCAL_ROOT_PARTN=\$(parted -sm "\$LOCAL_DEV_PATH" print | tail -1 | cut -d : -f 1)
LOCAL_DEV_ROOT_PATH=\$(lsblk -lpo mountpoint,path | grep '/ ' | awk '{print \$2}')
LOCAL_ROOT_START=\$(fdisk -lo start "\$LOCAL_DEV_PATH" | tail -1 | awk '{print \$1}') # blocks, 512B block size
LOCAL_ROOT_START=\$(( LOCAL_ROOT_START * 512 )) # bytes

sfdisk --delete -f "\$LOCAL_DEV_PATH" "\$LOCAL_ROOT_PARTN"
parted -s -a none "\$LOCAL_DEV_PATH" unit B mkpart primary ext4 "\$LOCAL_ROOT_START" 100%
resize2fs -f "\$LOCAL_DEV_ROOT_PATH"
sync
exit 0
EOF2

  debug 'DEBUG' 'Making /expand-fs.sh executable'
  chmod +x ${TMP_DIR}/expand-fs.sh

  echo '## ArchLinuxArm filesystem autoresizing at boot...'
  debug 'INFO' 'ArchLinuxArm filesystem autoresizing at boot'
  $SLEEPING
  return 0
}



# Function to print result
function print_result() {

  declare -i AFTER_SIZE=$(ls -l "$IMG_FILE" | cut -d ' ' -f 5)
  AFTER_SIZE=$(( AFTER_SIZE / 1024 / 1024 ))

  if [ "$UPDATE" != true ]; then
    echo '## Backup done.'
    echo '##############################################################################'
    echo "## Write to logfile: $DEBUG"
    echo "## Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "## Use exclude.txt: $EXCLUDE_FILE"
    if [ "$RESIZE2FS_RUN" = true ]; then
      echo "## $IMG_FILE is ${AFTER_SIZE}MiB with a root partition of $(( LOCAL_RESIZE2FS_MIN / 1024 / 1024 ))MiB."
      debug 'INFO' "$IMG_FILE is ${AFTER_SIZE}MiB with a root partition of $(( LOCAL_RESIZE2FS_MIN / 1024 / 1024 ))MiB"
    else
      echo "## $IMG_FILE is ${AFTER_SIZE}MiB with $(( ADDED_SPACE / 1024 / 1024 ))MiB extra space included."
      debug 'INFO' "$IMG_FILE is ${AFTER_SIZE}MiB with $(( ADDED_SPACE / 1024 / 1024 ))MiB extra space included"
    fi
    debug 'INFO' 'Img file created'
  else
    echo '## Backup done.'
    echo '##############################################################################'
    echo "## Write to logfile: $DEBUG"
    echo "## Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "## Use exclude.txt: $EXCLUDE_FILE"
    echo "## $IMG_FILE is ${AFTER_SIZE}MiB"
    debug 'INFO' "$IMG_FILE is ${AFTER_SIZE}MiB"
    debug 'INFO' 'Img file updated'
  fi
  if [ "$AUTOEXPAND" == true ]; then
    echo "## Please wait for the system to reboot after restoring an image with autoexpansion."
  fi
  echo '##############################################################################'
  debug 'INFO' 'Backup done'
  debug 'BREAK'
return 0
}



# Process the non-option arguments, checks/fixes if the imagefile comes before the options
while [ "$#" -gt 0 ];
do
  if [[ "$1" =~ ^- ]]; then
    shift
  elif [ -n "$IMG_FILE" ]; then
    ADDED_SPACE="$1"
    break
  else
    IMG_FILE="$1"
    ADDED_SPACE="$2"
    break
  fi
done

# Check if debugging is requested
if [ "$DEBUG" == true ]; then
  echo "## Debugging requested, writing to log file $LOG_FILE"
  debug 'INFO' "Debugging requested, writing to log file $LOG_FILE"
fi

# Set zoom type
if [ "$ZOOM" == false ]; then
  SLEEPING='sleep 1'
  echo '## Zoom speed NOT requested...'
  debug 'INFO' "Zoom speed NOT requested, setting SLEEPING=$SLEEPING | ZOOM=$ZOOM"
  $SLEEPING
else
  SLEEPING=''
  echo '## Zoom speed requested...'
  debug 'INFO' "Zoom speed requested, setting SLEEPING to empty variable | ZOOM=$ZOOM"
fi

# Check if the image file has the correct extension
if [[ "$IMG_FILE" != *.img ]]; then
  echo 'ERROR! File must have .img extension'
  debug 'ERROR' 'File must have .img extension, exit 3'
  exit 3
fi

# Setting ADDED_SPACE to 0 if RESIZE2FS_RUN option is enabled
if [ "$RESIZE2FS_RUN" == true ] && [ "$LOOPRUN" == false ]; then
  ADDED_SPACE=0
  debug 'INFO' '-a selected by user'
  debug 'DEBUG' "ADDED_SPACE=$ADDED_SPACE"
fi

# Setting adding ADDED_SPACE to 0 if update is requested and variable ADDED_SPACE is a zero value
if [ $UPDATE == true ] && [ -z "$ADDED_SPACE" ] && [ "$LOOPRUN" == false ]; then
  ADDED_SPACE=0
  debug 'INFO' '-U selected, -a not selected or extra space not provided by user, setting to ADDED_SPACE to 0 (non-zero value)'
  debug 'DEBUG' "ADDED_SPACE=$ADDED_SPACE"
fi

# Regular expression for whole numbers
RE='^[0-9]+$'

# Validate the added space argument as a whole number
# -z = zero value, -n = non-zero value, || = or, && = and
if ! [[ "$ADDED_SPACE" =~ $RE ]] && [ -n "$ADDED_SPACE" ]; then
  debug 'WARNING' 'User defined ADDED_SPACE is not a regualar expression (whole number)'
  COUNTER=0
  while ! [[ "$ADDED_SPACE" =~ $RE ]]
  do
    #if [ "$COUNTER" -gt 0 ] || [ -n "$ADDED_SPACE" ]; then
    if [ "$COUNTER" -gt 0 ]; then
      echo 'ERROR!'
      debug 'INFO' 'ERROR'
    fi
    echo 'Added space must be a whole number'
    echo 'How much space in MiB should be added?'
    debug 'INFO' 'Added space must be a whole number'
    debug 'INFO' 'How much space in MiB should be added?'
    read ADDED_SPACE
    (( COUNTER++ ))
    #(( COUNTER += 1 ))
    debug 'USER_INPUT' "User requested ${ADDED_SPACE}MiB as ADDED_SPACE"
  done
fi

if [ "$LOOPRUN" == true ]; then
  debug 'INFO' '--loop selected by user, running function: looprun'
  looprun
fi

if [ "$ADDED_SPACE" -ne 0 ]; then
  RESIZE_RUN=true
fi

echo '## Scanning filesystem and calculating...'

# Check what filesystem root is using
if lsblk -lo mountpoint,fstype | grep '/ ' | grep -q 'ext4'; then
  FSTYPE='ext4'
  debug 'INFO' 'ext4 root filesystem detected'
  debug 'DEBUG' "FSTYPE=$FSTYPE"
else
  FSTYPE='btrfs'
  debug 'INFO' 'btrfs root filesystem detected'
  debug 'DEBUG' "FSTYPE=$FSTYPE"
fi

# Check what partition table is in use and set LOCAL_DEV_PATH
if [ "$FSTYPE" == 'ext4' ]; then
  LOCAL_DEV_PTUUID=$(lsblk -lpo mountpoint,ptuuid | grep '/ ' | awk '{print $2}')
else
  LOCAL_DEV_PTUUID=$(lsblk -lpo fsroots,ptuuid | grep '/ ' | awk '{print $2}')
fi
LOCAL_DEV_PATH=$(lsblk -lpo ptuuid,type,path | grep "$LOCAL_DEV_PTUUID" | grep 'disk' | awk '{print $3}')
debug 'DEBUG' "LOCAL_DEV_PTUUID=$LOCAL_DEV_PTUUID | LOCAL_DEV_PATH=$LOCAL_DEV_PATH"

PARTITION_TABLE=$(parted "$LOCAL_DEV_PATH" print | grep 'Partition Table' | awk '{print $3}')
#PARTITION_TABLE=$(blkid "$LOCAL_DEV_PATH" | sed -n 's|^.*PTTYPE="\(\S\+\)".*|\1|p')
debug 'DEBUG' "PARTITION_TABLE=$PARTITION_TABLE"
debug 'DEBUG' "UPDATE=$UPDATE"
debug 'DEBUG' "RESIZE2FS_RUN=$RESIZE2FS_RUN"
debug 'DEBUG' "PROMPTS=$PROMPTS"
debug 'DEBUG' "AUTOEXPAND=$AUTOEXPAND"
debug 'DEBUG' "RESIZE_RUN=$RESIZE_RUN"
debug 'DEBUG' "RSYNC_DELETE=$RSYNC_DELETE"

# Check if usage of exclude.txt is requested
if [ "$EXCLUDE_FILE" == true ]; then
  debug 'INFO' "-f selected by user, using $(dirname $0)/exclude.txt"
  if ! [ -f $(dirname "$0")/exclude.txt ]; then
    echo 'ERROR! exclude.txt is not present in script directory!'
    debug 'ERROR' 'exclude.txt does not exist in script directory, exit 3'
    exit 3
  fi
  debug 'DEBUG' "$(dirname $0)/exclude.txt exists"
else
  debug 'INFO' '-f NOT selected by user, using default exclude directories'
fi

if [ "$UPDATE" != true ]; then
  debug 'INFO' 'Running function: make_img'
  debug 'BREAK'
  make_img
else
  debug 'INFO' '-U selected by user, running function: do_backup'
  debug 'BREAK'
  do_backup
fi

# Check if autoexpansion is requested and run required function
if [ "$AUTOEXPAND" == true ]; then
  echo '## Enabling fs-autoexpand...'
  debug 'INFO' 'Checking OS for autoexpand function'
  $SLEEPING
  if cat /etc/os-release | grep -i 'manjaro' >/dev/null; then
    echo '## Manjaro os detected...'
    debug 'INFO' 'Manjaro os detected'
    debug 'INFO' 'Running function: autoexpansion_manjaro'
    $SLEEPING
    autoexpansion_manjaro
  elif [ -e /etc/armbian-release ]; then
    debug 'INFO' 'Armbian os detected'
    debug 'INFO' 'Running function: autoexpansion_armbian'
    echo '## Armbian os detected...'
    $SLEEPING
    autoexpansion_armbian
  elif uname -a | grep -q 'raspberry' || [ -e /etc/apt/sources.list.d/raspi.list ]; then
    debug 'INFO' 'Raspberry pi detected'
    debug 'INFO' 'Running function: autoexpansion_rpi'
    echo '## Raspberry pi detected...'
    $SLEEPING
    autoexpansion_rpi
  elif grep -q 'archlinuxarm' /etc/os-release; then
    echo '## ArchLinuxArm os detected...'
    debug 'INFO' 'ArchLinuxArm os detected'
    debug 'INFO' 'Running function: autoexpansion_arch'
    $SLEEPING
    autoexpansion_arch
  else
    echo '## No autoexpand option available for this OS...'
    debug 'WARNING' 'No autoexpand option available for this OS'
    AUTOEXPAND='failed'
    $SLEEPING
  fi
fi

print_result

exit 0
